#!/usr/bin/env python3
"""
full_auto_pr.py - Fully automated PR workflow.

Platform-agnostic flow:
1. Analyze changes
2. Auto commit
3. Auto push
4. Auto create Issue (optional, via API)
5. Auto create PR linked to Issue (via API or web)
"""
from __future__ import annotations

import argparse
import os
import subprocess
import sys
from typing import List, Optional, Tuple

try:
    from repo_api import RepoAPI, CodeAnalyzer, RepoAPIError
except ImportError:
    print("Error: repo_api module not found.")
    print("Ensure repo_api.py is in the same directory.")
    sys.exit(1)


class Colors:
    GREEN = "\033[0;32m"
    BLUE = "\033[0;34m"
    YELLOW = "\033[1;33m"
    RED = "\033[0;31m"
    NC = "\033[0m"

    @staticmethod
    def enabled() -> bool:
        return sys.stdout.isatty() and os.name != "nt"

    @classmethod
    def apply(cls, color: str, text: str) -> str:
        return f"{color}{text}{cls.NC}" if cls.enabled() else text


def print_step(text: str) -> None:
    print(f"\n{Colors.apply(Colors.BLUE, f'=== {text} ===')}\n")


def print_success(text: str) -> None:
    print(Colors.apply(Colors.GREEN, f"[OK] {text}"))


def print_info(text: str) -> None:
    print(Colors.apply(Colors.GREEN, f"  {text}"))


def print_warn(text: str) -> None:
    print(Colors.apply(Colors.YELLOW, f"[WARN] {text}"))


def print_error(text: str) -> None:
    print(Colors.apply(Colors.RED, f"[ERROR] {text}"), file=sys.stderr)


def run_git(*args, cwd: str = ".", check: bool = True) -> Tuple[int, str, str]:
    result = subprocess.run(
        ["git"] + list(args), cwd=cwd, capture_output=True, text=True, check=False
    )
    if check and result.returncode != 0:
        raise subprocess.CalledProcessError(result.returncode, result.args, result.stdout, result.stderr)
    return result.returncode, result.stdout.strip(), result.stderr.strip()


def has_uncommitted_changes() -> bool:
    _, stdout, _ = run_git("status", "--porcelain", check=False)
    return bool(stdout.strip())


def get_changed_files() -> List[str]:
    _, stdout, _ = run_git("diff", "--cached", "--name-only", check=False)
    return stdout.splitlines() if stdout else []


def get_git_user_info() -> Tuple[str, str]:
    """Get git user.name and user.email for DCO signing."""
    _, name, _ = run_git("config", "user.name", check=False)
    _, email, _ = run_git("config", "user.email", check=False)
    return name, email


def build_commit_message(
    analyzer: CodeAnalyzer, target_branch: str, files: List[str], commits: List[str]
) -> Tuple[str, str]:
    change_type = analyzer.analyze_change_type(commits, files)
    if files:
        short_files = ", ".join(files[:3])
        if len(files) > 3:
            short_files += f" and {len(files) - 3} more"
        subject = f"{change_type}: update {short_files}"
    else:
        subject = f"{change_type}: code changes"

    summary = analyzer.generate_summary(commits, files, analyzer.detect_affected_components(files))

    # Get git user info for DCO signing
    name, email = get_git_user_info()
    dco_line = f"Signed-off-by: {name} <{email}>" if name and email else ""

    body_lines = [
        summary,
        "",
        "Auto-generated by create-pr skill",
    ]
    if dco_line:
        body_lines.append(dco_line)

    return subject, "\n".join(body_lines)


def smart_commit(analyzer: CodeAnalyzer, target_branch: str = "master") -> bool:
    print_step("Step 1: Analyze and Commit")

    _, branch, _ = run_git("rev-parse", "--abbrev-ref", "HEAD")
    print_info(f"Current branch: {branch}")

    _, remote_url, _ = run_git("config", "--get", "remote.origin.url")
    print_info(f"Remote: {remote_url}")

    if not has_uncommitted_changes():
        print_info("No uncommitted changes.")
        return True

    print_info("Staging changes...")
    run_git("add", ".")

    commits = analyzer.get_commit_messages(target_branch)
    files = analyzer.get_changed_files(target_branch)
    if not files:
        files = get_changed_files()

    subject, body = build_commit_message(analyzer, target_branch, files, commits)
    print_info(f"Commit subject: {subject}")

    run_git("commit", "-m", subject, "-m", body)
    print_success("Commit created")
    return True


def push_to_remote(branch: Optional[str] = None) -> bool:
    print_step("Step 2: Push to Remote")
    if branch is None:
        _, branch, _ = run_git("rev-parse", "--abbrev-ref", "HEAD")

    print_info(f"Pushing branch: {branch}")
    code, stdout, stderr = run_git("push", "-u", "origin", branch, check=False)
    if stdout:
        for line in stdout.splitlines():
            print(f"  {line}")
    if code != 0:
        print_error(f"Push failed: {stderr}")
        return False
    print_success("Push completed")
    return True


def create_issue(api: RepoAPI, analyzer: CodeAnalyzer, target_branch: str) -> Optional[int]:
    print_step("Step 3: Create Issue")
    commits = analyzer.get_commit_messages(target_branch)
    files = analyzer.get_changed_files(target_branch)
    components = analyzer.detect_affected_components(files)
    diff_stat = analyzer.get_diff_stat(target_branch)
    code_analysis = analyzer.analyze_code_changes(target_branch)

    title = analyzer.generate_issue_title(commits, components)
    description = analyzer.generate_issue_description(
        commits, files, components, diff_stat, code_analysis
    )

    print_info(f"Creating Issue via {api.platform} API...")
    result = api.create_issue(title, description)
    if result and result.get("iid"):
        issue_id = result["iid"]
        print_success("Issue created")
        print_info(f"Issue ID: #{issue_id}")
        print_info(f"Issue URL: {result.get('web_url')}")
        return issue_id
    print_warn("Issue creation failed or skipped, continuing without Issue.")
    return None


def create_pr(
    api: RepoAPI,
    analyzer: CodeAnalyzer,
    issue_id: Optional[int],
    target_branch: str,
) -> Optional[str]:
    print_step("Step 4: Create Pull Request")

    _, branch, _ = run_git("rev-parse", "--abbrev-ref", "HEAD")

    # Check if this is a fork repository
    is_fork = api.is_fork()
    fork_owner = api.get_fork_owner()
    upstream_owner = api.get_upstream_owner()

    # Build source branch based on fork status
    if is_fork and fork_owner:
        # For fork repos: head = fork_owner:branch (GitHub/GitCode format)
        source_branch = f"{fork_owner}:{branch}"
        print_info(f"Fork repository detected: {fork_owner}/{api.repo}")
        if upstream_owner:
            print_info(f"Upstream: {upstream_owner}/{api.repo}")
    else:
        # For non-fork repos: head = branch
        source_branch = branch

    commits = analyzer.get_commit_messages(target_branch)
    files = analyzer.get_changed_files(target_branch)
    components = analyzer.detect_affected_components(files)
    diff_stat = analyzer.get_diff_stat(target_branch)
    code_analysis = analyzer.analyze_code_changes(target_branch)

    title = analyzer.generate_pr_title(commits)
    description = analyzer.generate_pr_description(
        commits, files, components, diff_stat, issue_id, code_analysis
    )

    # Try API first
    print_info(f"Creating PR via {api.platform} API...")
    result = api.create_pr(source_branch, title, description, target_branch)

    if result and result.get("iid"):
        pr_url = result.get("web_url")
        print_success("PR created")
        print_info(f"PR ID: !{result.get('iid')}")
        print_info(f"PR URL: {pr_url}")
        return pr_url

    # Fallback: open browser
    print_warn("API failed or not configured, opening web interface...")
    import urllib.parse
    import tempfile

    # Save description to file
    temp_file = tempfile.NamedTemporaryFile(
        mode="w", suffix="_pr_desc.md", delete=False, encoding="utf-8", errors="ignore"
    )
    temp_file.write(description)
    temp_file.close()
    print_info(f"Description saved to: {temp_file.name}")

    # Build PR URL for the detected platform
    web_url = api.get_web_pr_url()
    if not web_url:
        # Try to extract from remote URL
        _, remote_url, _ = run_git("config", "--get", "remote.origin.url")
        import re
        match = re.search(r"https?://([^/]+)/([^/]+)/([^/]+?)(\.git)?$", remote_url)
        if match:
            domain, owner, repo = match.groups()[0:3]
            web_url = f"https://{domain}/{owner}/{repo}/pull/new"
        else:
            print_error("Could not determine PR URL from remote configuration")
            return None

    print_info(f"Opening: {web_url}")

    try:
        if os.name == "nt":
            os.startfile(web_url)
        elif sys.platform == "darwin":
            subprocess.run(["open", web_url], check=False)
        else:
            subprocess.run(["xdg-open", web_url], check=False)
        print_success("Browser opened")
    except Exception as e:
        print_error(f"Failed to open browser: {e}")
        print_info(f"Please visit: {web_url}")

    return web_url


def main() -> int:
    parser = argparse.ArgumentParser(
        description="Fully automated PR workflow (platform-agnostic)"
    )
    parser.add_argument("--token", help="Personal Access Token")
    parser.add_argument("--target", default="master", help="Target branch")
    parser.add_argument("--no-commit", action="store_true", help="Skip auto commit")
    parser.add_argument("--no-push", action="store_true", help="Skip auto push")
    parser.add_argument("--no-issue", action="store_true", help="Skip Issue creation")
    parser.add_argument("--analyze-only", action="store_true", help="Analyze only")

    args = parser.parse_args()

    print(Colors.apply(Colors.BLUE, "Create-PR: Auto commit -> push -> issue -> PR"))

    try:
        # Detect repo root (parent of scripts directory)
        repo_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        api = RepoAPI(args.token, repo_root=repo_root)
        analyzer = CodeAnalyzer(repo_root)

        _, branch, _ = run_git("rev-parse", "--abbrev-ref", "HEAD")
        print_info(f"Platform detected: {api.platform}")

        if args.analyze_only:
            print_step("Analyze Changes")
            commits = analyzer.get_commit_messages(args.target)
            files = analyzer.get_changed_files(args.target)
            components = analyzer.detect_affected_components(files)
            diff_stat = analyzer.get_diff_stat(args.target)
            print_info(f"Branch: {branch}")
            print_info(f"Changed files: {len(files)}")
            print_info(f"Commits: {len(commits)}")
            print_info(f"Affected components: {', '.join(components) if components else 'None'}")
            print_info(f"Change type: {analyzer.analyze_change_type(commits, files)}")
            print("")
            print("--- Diff Stat ---")
            print(diff_stat)
            return 0

        if not args.no_commit:
            if not smart_commit(analyzer, args.target):
                return 1
        else:
            print_info("Skipping auto commit")

        if not args.no_push:
            if not push_to_remote(branch):
                return 1
        else:
            print_info("Skipping auto push")

        issue_id = None
        if not args.no_issue:
            issue_id = create_issue(api, analyzer, args.target)
        else:
            print_info("Skipping Issue creation")

        pr_url = create_pr(api, analyzer, issue_id, args.target)
        if not pr_url:
            return 1

        print_step("Done")
        if issue_id:
            print(f"Issue: #{issue_id}")
        print(f"PR: {pr_url}")

        return 0

    except RepoAPIError as e:
        print_error(str(e))
        return 1
    except KeyboardInterrupt:
        print_warn("Cancelled by user")
        return 1
    except Exception as e:
        print_error(f"Unexpected error: {e}")
        return 1


if __name__ == "__main__":
    sys.exit(main())
