# è½¯æ€»çº¿å®‰å…¨å«å£« - å®‰å…¨è§„åˆ™è¯¦è§£ä¸ç¤ºä¾‹

> **æœ¬æ–‡æ¡£ç”¨é€”**ï¼šè¿™æ˜¯è½¯æ€»çº¿å®‰å…¨å«å£«çš„è¯¦ç»†è§„åˆ™å‚è€ƒæ–‡æ¡£ï¼ŒåŒ…å«40+æ¡å®‰å…¨è§„åˆ™çš„å®Œæ•´è¯´æ˜ã€ä»£ç ç¤ºä¾‹å’Œä¿®å¤æ–¹æ¡ˆã€‚
>
> **å¿«é€Ÿå‚è€ƒ**ï¼š
> - ğŸ“‹ [è§„åˆ™ç´¢å¼•å’Œå·¥ä½œæµç¨‹ â†’ ä¸»æ–‡æ¡£](../skill.md)
> - ğŸ“Š [å¸¸è§é”™è¯¯é€ŸæŸ¥è¡¨ â†’ ä¸»æ–‡æ¡£](../skill.md#å¸¸è§é”™è¯¯é€ŸæŸ¥è¡¨)
>
> **æ–‡æ¡£ç»„ç»‡**ï¼šæœ¬æ–‡æ¡£æŒ‰è§„åˆ™ç±»åˆ«ç»„ç»‡ï¼Œæ¯æ¡è§„åˆ™åŒ…å«ï¼š
> - é—®é¢˜æè¿°
> - é£é™©ç­‰çº§
> - é—®é¢˜ç¤ºä¾‹ï¼ˆâŒ é”™è¯¯ä»£ç ï¼‰
> - ä¿®å¤æ–¹æ¡ˆï¼ˆâœ… æ­£ç¡®ä»£ç ï¼‰
> - æ£€æŸ¥è¦ç‚¹

æœ¬æ–‡æ¡£è¯¦ç»†è¯´æ˜è½¯æ€»çº¿å®‰å…¨å«å£«çš„40+æ¡å®‰å…¨è§„åˆ™ï¼Œæ¯æ¡è§„åˆ™éƒ½åŒ…å«è¯¦ç»†çš„è§£é‡Šã€é—®é¢˜ä»£ç ç¤ºä¾‹å’Œä¿®å¤æ–¹æ¡ˆã€‚

---

## ç›®å½•

1. [æ—¥å¿—è§„èŒƒ](#1-æ—¥å¿—è§„èŒƒ)
2. [æŒ‡é’ˆå®‰å…¨](#2-æŒ‡é’ˆå®‰å…¨)
3. [ä¸´æ—¶å˜é‡æ£€æŸ¥](#3-ä¸´æ—¶å˜é‡æ£€æŸ¥)
4. [æ•°ç»„ä¸‹æ ‡æ£€æŸ¥](#4-æ•°ç»„ä¸‹æ ‡æ£€æŸ¥)
5. [é”ç®¡ç†æ£€æŸ¥](#5-é”ç®¡ç†æ£€æŸ¥)
6. [fdç®¡ç†æ£€æŸ¥](#6-fdç®¡ç†æ£€æŸ¥)
7. [å†…å­˜ç®¡ç†æ£€æŸ¥](#7-å†…å­˜ç®¡ç†æ£€æŸ¥)
8. [æ•æ„Ÿä¿¡æ¯æ£€æŸ¥](#8-æ•æ„Ÿä¿¡æ¯æ£€æŸ¥)
9. [æ•´æ•°è¿ç®—æ£€æŸ¥](#9-æ•´æ•°è¿ç®—æ£€æŸ¥)
10. [å¾ªç¯å˜é‡æ£€æŸ¥](#10-å¾ªç¯å˜é‡æ£€æŸ¥)
11. [å®‰å…¨å‡½æ•°æ£€æŸ¥](#11-å®‰å…¨å‡½æ•°æ£€æŸ¥)
12. [æƒé™æ ¡éªŒæ£€æŸ¥](#12-æƒé™æ ¡éªŒæ£€æŸ¥)
13. [å¤–éƒ¨è¾“å…¥æ ¡éªŒæ£€æŸ¥](#13-å¤–éƒ¨è¾“å…¥æ ¡éªŒæ£€æŸ¥)
14. [å¤–éƒ¨æ•°æ®æœ‰æ•ˆæ€§æ£€æŸ¥](#14-å¤–éƒ¨æ•°æ®æœ‰æ•ˆæ€§æ£€æŸ¥)
15. [å¸¸è§é—®é¢˜æ£€æŸ¥](#15-å¸¸è§é—®é¢˜æ£€æŸ¥)

---

## 1. æ—¥å¿—è§„èŒƒ

### è§„åˆ™ 1.1: ç¦æ­¢è¿”å› SOFTBUS_ERR

**é—®é¢˜æè¿°**ï¼š
å‡½æ•°è¿”å›å€¼ä½¿ç”¨é€šç”¨çš„ `SOFTBUS_ERR` é”™è¯¯ç ï¼Œå¯¼è‡´é—®é¢˜å®šä½å›°éš¾ã€‚åº”è¿”å›å…·ä½“çš„é”™è¯¯ç ã€‚

**é£é™©ç­‰çº§**ï¼šâš ï¸ è­¦å‘Š

**é—®é¢˜ç¤ºä¾‹**ï¼š
```c
int32_t ConnectToDevice(const char *networkId) {
    if (networkId == NULL) {
        HILOG_ERROR("networkId is NULL");
        return SOFTBUS_ERR;  // âŒ é€šç”¨é”™è¯¯ç 
    }

    if (strlen(networkId) > MAX_NETWORK_ID_LEN) {
        HILOG_ERROR("networkId too long");
        return SOFTBUS_ERR;  // âŒ é€šç”¨é”™è¯¯ç 
    }

    return SOFTBUS_OK;
}
```

**ä¿®å¤æ–¹æ¡ˆ**ï¼š
```c
int32_t ConnectToDevice(const char *networkId) {
    if (networkId == NULL) {
        HILOG_ERROR("networkId is NULL");
        return SOFTBUS_INVALID_PARAM;  // âœ… å…·ä½“é”™è¯¯ç 
    }

    if (strlen(networkId) > MAX_NETWORK_ID_LEN) {
        HILOG_ERROR("networkId too long: %{public}zu", strlen(networkId));
        return SOFTBUS_INVALID_PARAM;  // âœ… å…·ä½“é”™è¯¯ç 
    }

    return SOFTBUS_OK;
}
```

**æ£€æŸ¥è¦ç‚¹**ï¼š
- ä½¿ç”¨ Grep æœç´¢ `return SOFTBUS_ERR`
- ç¡®è®¤æ˜¯å¦å¯ä»¥è¿”å›æ›´å…·ä½“çš„é”™è¯¯ç 
- å¸¸ç”¨å…·ä½“é”™è¯¯ç ï¼š`SOFTBUS_INVALID_PARAM`ã€`SOFTBUS_MALLOC_ERR`ã€`SOFTBUS_MUTEX_ERR` ç­‰

---

## 2. æŒ‡é’ˆå®‰å…¨

### è§„åˆ™ 2.1: ç¦æ­¢æŒ‡é’ˆä½è¿ç®—

**é—®é¢˜æè¿°**ï¼š
å¯¹æŒ‡é’ˆè¿›è¡Œä½è¿ç®—ï¼ˆ`&`, `|`, `^`, `~`, `<<`, `>>`ï¼‰æ˜¯æœªå®šä¹‰è¡Œä¸ºï¼Œå¯èƒ½å¯¼è‡´ç¨‹åºå´©æºƒæˆ–å®‰å…¨æ¼æ´ã€‚

**é£é™©ç­‰çº§**ï¼šğŸ”´ ä¸¥é‡

**é—®é¢˜ç¤ºä¾‹**ï¼š
```c
char *ptr = (char *)0x12345678;
uint32_t value = *(uint32_t *)ptr;  // âŒ å¯èƒ½æœªå¯¹é½
uint32_t result = ptr & 0xF;        // âŒ æŒ‡é’ˆä½è¿ç®—
char *aligned = (ptr + 15) & ~15;   // âŒ æŒ‡é’ˆä½è¿ç®—
```

**ä¿®å¤æ–¹æ¡ˆ**ï¼š
```c
// ä½¿ç”¨æ ‡å‡†å·¥å…·å¯¹é½
#include <stdalign.h>
alignas(16) char buffer[256];

// ä½¿ç”¨ uintptr_t è¿›è¡Œåœ°å€è¿ç®—
uintptr_t addr = (uintptr_t)ptr;
uint32_t alignment = addr & 0xF;  // âœ… å¯¹æ•´æ•°è¿›è¡Œä½è¿ç®—
uintptr_t aligned = ((addr + 15) / 16) * 16;  // âœ… å¯¹é½è®¡ç®—
char *alignedPtr = (char *)aligned;
```

**æ£€æŸ¥è¦ç‚¹**ï¼š
- æœç´¢æ¨¡å¼ï¼š`ptr &`, `ptr |`, `ptr ^`, `~ptr`, `ptr <<`, `ptr >>`
- ç¡®è®¤æ“ä½œæ•°æ˜¯å¦ä¸ºæŒ‡é’ˆç±»å‹
- å»ºè®®ä½¿ç”¨ `uintptr_t` è¿›è¡Œåœ°å€è¿ç®—

---

### è§„åˆ™ 2.2: æ£€æŸ¥ sizeof ä½¿ç”¨

**é—®é¢˜æè¿°**ï¼š
ä½¿ç”¨ `sizeof(ptr)` è·å–çš„æ˜¯æŒ‡é’ˆå¤§å°ï¼ˆ4æˆ–8å­—èŠ‚ï¼‰ï¼Œè€ŒéæŒ‡å‘å¯¹è±¡çš„å¤§å°ã€‚

**é£é™©ç­‰çº§**ï¼šğŸ”´ ä¸¥é‡

**é—®é¢˜ç¤ºä¾‹**ï¼š
```c
void ProcessData(int32_t *data) {
    memset(data, 0, sizeof(data));  // âŒ åªæ¸…é›¶4æˆ–8å­—èŠ‚
    // åº”è¯¥æ¸…é›¶æ•´ä¸ªæ•°ç»„
}

void CopyData(char *src) {
    char *dst = SoftBusMalloc(sizeof(src));  // âŒ åªåˆ†é…4æˆ–8å­—èŠ‚
    // åº”è¯¥åˆ†é…strlen(src) + 1
}
```

**ä¿®å¤æ–¹æ¡ˆ**ï¼š
```c
void ProcessData(int32_t *data, size_t count) {
    memset(data, 0, sizeof(*data) * count);  // âœ… ä½¿ç”¨ sizeof(*ptr)
    // æˆ–è€…
    memset(data, 0, sizeof(int32_t) * count);  // âœ… ä½¿ç”¨å…·ä½“ç±»å‹
}

void CopyData(const char *src) {
    size_t len = strlen(src);
    char *dst = SoftBusMalloc(len + 1);  // âœ… åŸºäºå®é™…é•¿åº¦åˆ†é…
    if (dst != NULL) {
        memcpy(dst, src, len + 1);
    }
}
```

**æ£€æŸ¥è¦ç‚¹**ï¼š
- æœç´¢ `sizeof(ptr)` æˆ– `sizeof(p_)` ç­‰æŒ‡é’ˆå˜é‡
- ç¡®è®¤æ˜¯å¦åº”ä½¿ç”¨ `sizeof(*ptr)` æˆ–å…·ä½“ç±»å‹å¤§å°
- å†…å­˜åˆ†é…åº”åŸºäºå®é™…æ•°æ®å¤§å°ï¼Œè€ŒéæŒ‡é’ˆå¤§å°

---

### è§„åˆ™ 2.3: ç©ºæŒ‡é’ˆè§£å¼•ç”¨æ£€æŸ¥

**é—®é¢˜æè¿°**ï¼š
åœ¨ä½¿ç”¨æŒ‡é’ˆå‰æœªæ£€æŸ¥æ˜¯å¦ä¸º NULLï¼Œå¯èƒ½å¯¼è‡´ç©ºæŒ‡é’ˆè§£å¼•ç”¨å´©æºƒã€‚

**é£é™©ç­‰çº§**ï¼šğŸ”´ ä¸¥é‡

**é—®é¢˜ç¤ºä¾‹**ï¼š
```c
int32_t ProcessMessage(Message *msg) {
    msg->type = MSG_TYPE_REQUEST;  // âŒ æœªåˆ¤ç©º
    return ProcessData(msg->data);  // âŒ æœªåˆ¤ç©º
}

char* GetDeviceName(const DeviceInfo *info) {
    return info->name;  // âŒ æœªåˆ¤ç©º
}
```

**ä¿®å¤æ–¹æ¡ˆ**ï¼š
```c
int32_t ProcessMessage(Message *msg) {
    if (msg == NULL) {  // âœ… åˆ¤ç©º
        HILOG_ERROR("msg is NULL");
        return SOFTBUS_INVALID_PARAM;
    }

    msg->type = MSG_TYPE_REQUEST;

    if (msg->data == NULL) {  // âœ… åˆ¤ç©º
        HILOG_ERROR("msg->data is NULL");
        return SOFTBUS_INVALID_PARAM;
    }

    return ProcessData(msg->data);
}

char* GetDeviceName(const DeviceInfo *info) {
    if (info == NULL || info->name == NULL) {  // âœ… åˆ¤ç©º
        HILOG_ERROR("info or info->name is NULL");
        return NULL;
    }
    return info->name;
}
```

**æ£€æŸ¥è¦ç‚¹**ï¼š
- æœç´¢ `*ptr`, `ptr->` æ¨¡å¼
- ç¡®è®¤ä½¿ç”¨å‰æ˜¯å¦æœ‰ NULL æ£€æŸ¥
- ç‰¹åˆ«æ³¨æ„å‡½æ•°å‚æ•°ã€è¿”å›å€¼ã€malloc/calloc ç»“æœ

---

### è§„åˆ™ 2.4: IPC ç»“æœåˆ¤ç©º

**é—®é¢˜æè¿°**ï¼š
IPC æµç¨‹ä¸­çš„ `ReadCString`ã€`ReadRawData` ç­‰å‡½æ•°è¿”å›å€¼æœªåˆ¤ç©ºã€‚

**é£é™©ç­‰çº§**ï¼šğŸ”´ ä¸¥é‡

**é—®é¢˜ç¤ºä¾‹**ï¼š
```c
int32_t HandleIpcMessage(MessageParcel &data) {
    char *networkId = data.ReadCString();  // âŒ æœªåˆ¤ç©º
    uint32_t len = data.ReadUint32();      // âŒ æœªæ£€æŸ¥è¯»å–æ˜¯å¦æˆåŠŸ

    HILOG_INFO("networkId=%{public}s", networkId);  // å¯èƒ½å´©æºƒ

    return ProcessDevice(networkId, len);
}
```

**ä¿®å¤æ–¹æ¡ˆ**ï¼š
```c
int32_t HandleIpcMessage(MessageParcel &data) {
    char *networkId = data.ReadCString();
    if (networkId == NULL) {  // âœ… åˆ¤ç©º
        HILOG_ERROR("ReadCString failed");
        return SOFTBUS_READ_MSG_ERR;
    }

    uint32_t len;
    if (!data.ReadUint32(len)) {  // âœ… æ£€æŸ¥è¯»å–æ˜¯å¦æˆåŠŸ
        HILOG_ERROR("ReadUint32 failed");
        return SOFTBUS_READ_MSG_ERR;
    }

    HILOG_INFO("networkId=%{private}s", networkId);

    return ProcessDevice(networkId, len);
}
```

**æ£€æŸ¥è¦ç‚¹**ï¼š
- `ReadCString`, `ReadRawData`, `ReadBuffer` ç­‰å‡½æ•°è¿”å›å€¼å¿…é¡»åˆ¤ç©º
- `ReadInt32`, `ReadUint32` ç­‰å‡½æ•°åº”æ£€æŸ¥è¿”å›å€¼ï¼ˆboolï¼‰
- åœ¨ä½¿ç”¨è¯»å–çš„æ•°æ®å‰å¿…é¡»éªŒè¯è¯»å–æˆåŠŸ

---

## 3. ä¸´æ—¶å˜é‡æ£€æŸ¥

### è§„åˆ™ 3.1: æŒ‡é’ˆå˜é‡åˆå§‹åŒ–

**é—®é¢˜æè¿°**ï¼š
æŒ‡é’ˆå˜é‡å£°æ˜æ—¶æœªåˆå§‹åŒ–ï¼Œä½¿ç”¨æ—¶å¯èƒ½åŒ…å«éšæœºå€¼ã€‚

**é£é™©ç­‰çº§**ï¼šğŸ”´ ä¸¥é‡

**é—®é¢˜ç¤ºä¾‹**ï¼š
```c
int32_t ProcessData(void) {
    char *buffer;  // âŒ æœªåˆå§‹åŒ–
    int32_t result;

    result = AllocateBuffer(&buffer);
    if (result != SOFTBUS_OK) {
        // buffer æœªåˆå§‹åŒ–ï¼Œå¦‚æœåœ¨é”™è¯¯å¤„ç†ä¸­ä½¿ç”¨ä¼šå´©æºƒ
        return result;
    }

    // ä½¿ç”¨ buffer...
    return SOFTBUS_OK;
}
```

**ä¿®å¤æ–¹æ¡ˆ**ï¼š
```c
int32_t ProcessData(void) {
    char *buffer = NULL;  // âœ… åˆå§‹åŒ–ä¸º NULL
    int32_t result;

    result = AllocateBuffer(&buffer);
    if (result != SOFTBUS_OK) {
        // å®‰å…¨ï¼šbuffer æ˜¯ NULL
        return result;
    }

    if (buffer == NULL) {  // âœ… å†æ¬¡æ£€æŸ¥
        HILOG_ERROR("buffer is NULL");
        return SOFTBUS_ERR;
    }

    // ä½¿ç”¨ buffer...
    return SOFTBUS_OK;
}
```

**æ£€æŸ¥è¦ç‚¹**ï¼š
- æŒ‡é’ˆå˜é‡å£°æ˜æ—¶å¿…é¡»åˆå§‹åŒ–ä¸º `NULL` æˆ–æœ‰æ•ˆå€¼
- ç‰¹åˆ«æ³¨æ„å±€éƒ¨å˜é‡æŒ‡é’ˆ
- æ£€æŸ¥æ‰€æœ‰æŒ‡é’ˆå£°æ˜è¯­å¥

---

### è§„åˆ™ 3.2: èµ„æºæè¿°ç¬¦å˜é‡åˆå§‹åŒ–

**é—®é¢˜æè¿°**ï¼š
æ–‡ä»¶æè¿°ç¬¦ã€socket ç­‰èµ„æºæè¿°ç¬¦æœªåˆå§‹åŒ–ï¼Œå¯èƒ½å¯¼è‡´é”™è¯¯çš„å…³é—­æ“ä½œã€‚

**é£é™©ç­‰çº§**ï¼šğŸ”´ ä¸¥é‡

**é—®é¢˜ç¤ºä¾‹**ï¼š
```c
int32_t CreateConnection(void) {
    int32_t fd;  // âŒ æœªåˆå§‹åŒ–
    int32_t ret;

    ret = ConnectToServer(&fd);
    if (ret != SOFTBUS_OK) {
        // fd æœªåˆå§‹åŒ–ï¼Œå…³é—­æ“ä½œå¯èƒ½è¯¯å…³å…¶ä»–fd
        SoftBusSocketClose(fd);
        return ret;
    }

    // ä½¿ç”¨ fd...
    SoftBusSocketClose(fd);
    return SOFTBUS_OK;
}
```

**ä¿®å¤æ–¹æ¡ˆ**ï¼š
```c
int32_t CreateConnection(void) {
    int32_t fd = -1;  // âœ… åˆå§‹åŒ–ä¸ºæ— æ•ˆå€¼
    int32_t ret;

    ret = ConnectToServer(&fd);
    if (ret != SOFTBUS_OK) {
        // å®‰å…¨ï¼šfd æ˜¯ -1
        return ret;
    }

    if (fd < 0) {  // âœ… æ£€æŸ¥æœ‰æ•ˆæ€§
        HILOG_ERROR("Invalid fd: %{public}d", fd);
        return SOFTBUS_ERR;
    }

    // ä½¿ç”¨ fd...
    SoftBusSocketClose(fd);
    fd = -1;  // âœ… å…³é—­åç½®ä¸ºæ— æ•ˆå€¼
    return SOFTBUS_OK;
}
```

**æ£€æŸ¥è¦ç‚¹**ï¼š
- fdã€socket ç­‰èµ„æºæè¿°ç¬¦åˆå§‹åŒ–ä¸º `-1`
- å…³é—­åç½®ä¸º `-1`
- ä½¿ç”¨å‰æ£€æŸ¥æœ‰æ•ˆæ€§

---

### è§„åˆ™ 3.3: bool å˜é‡åˆå§‹åŒ–

**é—®é¢˜æè¿°**ï¼š
bool å˜é‡æœªåˆå§‹åŒ–ï¼Œä½¿ç”¨æ—¶å€¼ä¸ç¡®å®šã€‚

**é£é™©ç­‰çº§**ï¼šğŸŸ¡ è­¦å‘Š

**é—®é¢˜ç¤ºä¾‹**ï¼š
```c
int32_t ProcessRequest(Request *req) {
    bool isValid;  // âŒ æœªåˆå§‹åŒ–

    ValidateRequest(req, &isValid);

    if (isValid) {  // isValid å€¼ä¸ç¡®å®š
        // å¤„ç†è¯·æ±‚
    }
    return SOFTBUS_OK;
}
```

**ä¿®å¤æ–¹æ¡ˆ**ï¼š
```c
int32_t ProcessRequest(Request *req) {
    bool isValid = false;  // âœ… åˆå§‹åŒ–ä¸º false

    ValidateRequest(req, &isValid);

    if (isValid) {
        // å¤„ç†è¯·æ±‚
    }
    return SOFTBUS_OK;
}
```

**æ£€æŸ¥è¦ç‚¹**ï¼š
- bool å˜é‡å£°æ˜æ—¶å¿…é¡»åˆå§‹åŒ–ä¸º `true` æˆ– `false`
- é»˜è®¤å€¼é€šå¸¸æ˜¯ `false`ï¼ˆå®‰å…¨é»˜è®¤å€¼ï¼‰

---

## 4. æ•°ç»„ä¸‹æ ‡æ£€æŸ¥

### è§„åˆ™ 4.1: æ•°ç»„è¶Šç•Œé£é™©

**é—®é¢˜æè¿°**ï¼š
è®¿é—®æ•°ç»„å…ƒç´ æ—¶æœªéªŒè¯ä¸‹æ ‡èŒƒå›´ï¼Œå¯èƒ½å¯¼è‡´ç¼“å†²åŒºæº¢å‡ºã€‚

**é£é™©ç­‰çº§**ï¼šğŸ”´ ä¸¥é‡

**é—®é¢˜ç¤ºä¾‹**ï¼š
```c
#define MAX_DEVICES 32
static DeviceInfo g_devices[MAX_DEVICES];

int32_t GetDevice(uint32_t index) {
    // âŒ æœªéªŒè¯ index èŒƒå›´
    return g_devices[index].id;
}

int32_t UpdateDeviceStatus(uint32_t index, int32_t status) {
    // âŒ æœªéªŒè¯ index èŒƒå›´
    g_devices[index].status = status;
    return SOFTBUS_OK;
}
```

**ä¿®å¤æ–¹æ¡ˆ**ï¼š
```c
#define MAX_DEVICES 32
static DeviceInfo g_devices[MAX_DEVICES];

int32_t GetDevice(uint32_t index) {
    if (index >= MAX_DEVICES) {  // âœ… éªŒè¯èŒƒå›´
        HILOG_ERROR("Invalid index: %{public}u (max: %{public}d)", index, MAX_DEVICES);
        return SOFTBUS_INVALID_PARAM;
    }
    return g_devices[index].id;
}

int32_t UpdateDeviceStatus(uint32_t index, int32_t status) {
    if (index >= MAX_DEVICES) {  // âœ… éªŒè¯èŒƒå›´
        HILOG_ERROR("Invalid index: %{public}u (max: %{public}d)", index, MAX_DEVICES);
        return SOFTBUS_INVALID_PARAM;
    }
    g_devices[index].status = status;
    return SOFTBUS_OK;
}
```

**æ£€æŸ¥è¦ç‚¹**ï¼š
- æ‰€æœ‰æ•°ç»„è®¿é—®å‰å¿…é¡»éªŒè¯ä¸‹æ ‡
- æ£€æŸ¥ `arr[index]`, `arr[i]` ç­‰æ¨¡å¼
- åŒæ—¶æ£€æŸ¥ä¸‹æ ‡ç±»å‹ï¼ˆsigned/unsignedï¼‰

---

### è§„åˆ™ 4.2: å¤–éƒ¨è¾“å…¥ä¸‹æ ‡åˆæ³•æ€§æ ¡éªŒ

**é—®é¢˜æè¿°**ï¼š
æ¥è‡ªå¤–éƒ¨çš„ä¸‹æ ‡å€¼ï¼ˆå¦‚ç½‘ç»œæ¶ˆæ¯ã€ç”¨æˆ·è¾“å…¥ï¼‰å¿…é¡»ä¸¥æ ¼æ ¡éªŒã€‚

**é£é™©ç­‰çº§**ï¼šğŸ”´ ä¸¥é‡

**é—®é¢˜ç¤ºä¾‹**ï¼š
```c
int32_t HandleNetworkMessage(const char *data, uint32_t len) {
    uint32_t index = *(uint32_t *)data;  // âŒ æ¥è‡ªç½‘ç»œçš„å€¼

    // ç›´æ¥ä½¿ç”¨å¤–éƒ¨è¾“å…¥ä½œä¸ºä¸‹æ ‡
    return g_devices[index].id;
}

int32_t ProcessUserRequest(int32_t userId, int32_t slotId) {
    // âŒ ç”¨æˆ·è¾“å…¥æœªéªŒè¯
    return userTable[userId].slots[slotId];
}
```

**ä¿®å¤æ–¹æ¡ˆ**ï¼š
```c
int32_t HandleNetworkMessage(const char *data, uint32_t len) {
    if (len < sizeof(uint32_t)) {
        HILOG_ERROR("Message too short");
        return SOFTBUS_ERR;
    }

    uint32_t index = *(uint32_t *)data;

    // âœ… ä¸¥æ ¼éªŒè¯å¤–éƒ¨è¾“å…¥
    if (index >= MAX_DEVICES) {
        HILOG_ERROR("Invalid index from network: %{public}u", index);
        return SOFTBUS_INVALID_PARAM;
    }

    return g_devices[index].id;
}

int32_t ProcessUserRequest(int32_t userId, int32_t slotId) {
    // âœ… éªŒè¯æ‰€æœ‰å¤–éƒ¨è¾“å…¥
    if (userId < 0 || userId >= MAX_USERS) {
        HILOG_ERROR("Invalid userId: %{public}d", userId);
        return SOFTBUS_INVALID_PARAM;
    }

    if (slotId < 0 || slotId >= MAX_SLOTS) {
        HILOG_ERROR("Invalid slotId: %{public}d", slotId);
        return SOFTBUS_INVALID_PARAM;
    }

    return userTable[userId].slots[slotId];
}
```

**æ£€æŸ¥è¦ç‚¹**ï¼š
- æ‰€æœ‰æ¥è‡ªç½‘ç»œã€ç”¨æˆ·è¾“å…¥ã€æ–‡ä»¶çš„ä¸‹æ ‡å¿…é¡»æ ¡éªŒ
- æ£€æŸ¥ä¸‹é™å’Œä¸Šé™ï¼ˆ>= 0 && < MAXï¼‰
- è®°å½•éæ³•è¾“å…¥å€¼ç”¨äºè°ƒè¯•

---

## 5. é”ç®¡ç†æ£€æŸ¥

### è§„åˆ™ 5.1: SoftBusMutexLock ä¸ SoftBusMutexUnlock æˆå¯¹ä½¿ç”¨

**é—®é¢˜æè¿°**ï¼š
Lock å’Œ Unlock ä¸æˆå¯¹ï¼Œå¯èƒ½å¯¼è‡´æ­»é”æˆ–æ•°æ®ç«äº‰ã€‚

**é£é™©ç­‰çº§**ï¼šğŸ”´ ä¸¥é‡

**é—®é¢˜ç¤ºä¾‹**ï¼š
```c
int32_t ProcessData(void) {
    SoftBusMutexLock(&g_mutex);

    if (errorCondition) {
        return SOFTBUS_ERR;  // âŒ å¿˜è®°è§£é”
    }

    if (anotherError) {
        goto cleanup;  // âŒ è·³è¿‡è§£é”
    }

    SoftBusMutexUnlock(&g_mutex);
    return SOFTBUS_OK;

cleanup:
    // å¿˜è®°è§£é”
    return SOFTBUS_ERR;
}
```

**ä¿®å¤æ–¹æ¡ˆ**ï¼š
```c
int32_t ProcessData(void) {
    int32_t ret = SoftBusMutexLock(&g_mutex);
    if (ret != 0) {
        HILOG_ERROR("Lock failed: %{public}d", ret);
        return SOFTBUS_MUTEX_ERR;
    }

    if (errorCondition) {
        SoftBusMutexUnlock(&g_mutex);  // âœ… æ‰€æœ‰è¿”å›è·¯å¾„éƒ½è§£é”
        return SOFTBUS_ERR;
    }

    if (anotherError) {
        SoftBusMutexUnlock(&g_mutex);  // âœ… æ‰€æœ‰è¿”å›è·¯å¾„éƒ½è§£é”
        return SOFTBUS_ERR;
    }

    SoftBusMutexUnlock(&g_mutex);
    return SOFTBUS_OK;
}
```

**æ£€æŸ¥è¦ç‚¹**ï¼š
- æ¯ä¸ª Lock å¿…é¡»æœ‰å¯¹åº”çš„ Unlock
- æ£€æŸ¥æ‰€æœ‰è¿”å›è·¯å¾„ï¼ˆreturnã€gotoï¼‰
- ä½¿ç”¨æ§åˆ¶æµåˆ†æéªŒè¯æˆå¯¹æ€§

---

### è§„åˆ™ 5.2: é”å˜é‡ä¸€è‡´æ€§

**é—®é¢˜æè¿°**ï¼š
Lock å’Œ Unlock ä½¿ç”¨ä¸åŒçš„é”å˜é‡ï¼Œå¯¼è‡´åŒæ­¥å¤±è´¥ã€‚

**é£é™©ç­‰çº§**ï¼šğŸ”´ ä¸¥é‡

**é—®é¢˜ç¤ºä¾‹**ï¼š
```c
static SoftBusMutex g_mutex1;
static SoftBusMutex g_mutex2;

int32_t ProcessData(void) {
    SoftBusMutexLock(&g_mutex1);

    // ä¸´ç•ŒåŒºæ“ä½œ

    SoftBusMutexUnlock(&g_mutex2);  // âŒ é”å˜é‡ä¸ä¸€è‡´ï¼
    return SOFTBUS_OK;
}
```

**ä¿®å¤æ–¹æ¡ˆ**ï¼š
```c
int32_t ProcessData(void) {
    int32_t ret = SoftBusMutexLock(&g_mutex1);
    if (ret != 0) {
        return SOFTBUS_MUTEX_ERR;
    }

    // ä¸´ç•ŒåŒºæ“ä½œ

    ret = SoftBusMutexUnlock(&g_mutex1);  // âœ… ä½¿ç”¨åŒä¸€ä¸ªé”
    if (ret != 0) {
        HILOG_ERROR("Unlock failed: %{public}d", ret);
    }
    return SOFTBUS_OK;
}
```

**æ£€æŸ¥è¦ç‚¹**ï¼š
- Lock å’Œ Unlock çš„é”å˜é‡å¿…é¡»ä¸€è‡´
- æ³¨æ„å˜é‡åç›¸ä¼¼çš„é”ï¼ˆå¦‚ mutex1, mutex2ï¼‰
- ä½¿ç”¨å®å®šä¹‰æˆ– RAII æ¨¡å¼é¿å…é”™è¯¯

---

### è§„åˆ™ 5.3: æ‰€æœ‰è¿”å›è·¯å¾„é‡Šæ”¾é”

**é—®é¢˜æè¿°**ï¼š
éƒ¨åˆ†é”™è¯¯å¤„ç†è·¯å¾„å¿˜è®°é‡Šæ”¾é”ã€‚

**é£é™©ç­‰çº§**ï¼šğŸ”´ ä¸¥é‡

**é—®é¢˜ç¤ºä¾‹**ï¼š
```c
int32_t MultiStepProcess(void) {
    SoftBusMutexLock(&g_mutex);

    if (step1() != SOFTBUS_OK) {
        SoftBusMutexUnlock(&g_mutex);
        return SOFTBUS_ERR;
    }

    if (step2() != SOFTBUS_OK) {
        // âŒ å¿˜è®°è§£é”
        return SOFTBUS_ERR;
    }

    if (step3() != SOFTBUS_OK) {
        SoftBusMutexUnlock(&g_mutex);
        return SOFTBUS_ERR;
    }

    SoftBusMutexUnlock(&g_mutex);
    return SOFTBUS_OK;
}
```

**ä¿®å¤æ–¹æ¡ˆ**ï¼š
```c
int32_t MultiStepProcess(void) {
    int32_t ret = SoftBusMutexLock(&g_mutex);
    if (ret != 0) {
        return SOFTBUS_MUTEX_ERR;
    }

    if (step1() != SOFTBUS_OK) {
        SoftBusMutexUnlock(&g_mutex);
        return SOFTBUS_ERR;
    }

    if (step2() != SOFTBUS_OK) {
        SoftBusMutexUnlock(&g_mutex);  // âœ… æ‰€æœ‰è·¯å¾„éƒ½è§£é”
        return SOFTBUS_ERR;
    }

    if (step3() != SOFTBUS_OK) {
        SoftBusMutexUnlock(&g_mutex);
        return SOFTBUS_ERR;
    }

    SoftBusMutexUnlock(&g_mutex);
    return SOFTBUS_OK;
}
```

**æ£€æŸ¥è¦ç‚¹**ï¼š
- éå†æ‰€æœ‰å¯èƒ½çš„é€€å‡ºè·¯å¾„
- ç¡®ä¿ Unlock åœ¨æ¯ä¸ª return å‰è°ƒç”¨
- ä½¿ç”¨ goto ç»Ÿä¸€æ¸…ç†ä»£ç ä¹Ÿæ˜¯ä¸€ç§æ–¹æ¡ˆ

---

## 6. fdç®¡ç†æ£€æŸ¥

### è§„åˆ™ 6.1: SoftBusSocketCreate ä¸ SoftBusSocketClose/SoftBusSocketShutDown æˆå¯¹ä½¿ç”¨

**é—®é¢˜æè¿°**ï¼š
Socket åˆ›å»ºå’Œå…³é—­ä¸æˆå¯¹ï¼Œå¯¼è‡´èµ„æºæ³„æ¼ã€‚

**é£é™©ç­‰çº§**ï¼šğŸ”´ ä¸¥é‡

**é—®é¢˜ç¤ºä¾‹**ï¼š
```c
int32_t CreateServer(void) {
    int32_t fd = SoftBusSocketCreate();
    if (fd < 0) {
        return SOFTBUS_ERR;
    }

    if (BindSocket(fd) != SOFTBUS_OK) {
        return SOFTBUS_ERR;  // âŒ å¿˜è®°å…³é—­ fd
    }

    // ä¿å­˜ fd åˆ°å…¨å±€å˜é‡
    g_serverFd = fd;
    return SOFTBUS_OK;
}
```

**ä¿®å¤æ–¹æ¡ˆ**ï¼š
```c
int32_t CreateServer(void) {
    int32_t fd = SoftBusSocketCreate();
    if (fd < 0) {
        HILOG_ERROR("Socket create failed");
        return SOFTBUS_SOCKET_ERR;
    }

    if (BindSocket(fd) != SOFTBUS_OK) {
        SoftBusSocketClose(fd);  // âœ… é”™è¯¯æ—¶å…³é—­
        return SOFTBUS_ERR;
    }

    // ä¿å­˜ fd åˆ°å…¨å±€å˜é‡
    g_serverFd = fd;
    return SOFTBUS_OK;
}
```

**æ£€æŸ¥è¦ç‚¹**ï¼š
- æ¯ä¸ª SocketCreate å¿…é¡»æœ‰å¯¹åº”çš„ SocketClose
- æ‰€æœ‰é”™è¯¯è·¯å¾„éƒ½è¦å…³é—­ fd
- fd å…³é—­åç½®ä¸º -1

---

### è§„åˆ™ 6.2: fd æ˜¯å¦æ­£ç¡®å…³é—­

**é—®é¢˜æè¿°**ï¼š
fd åœ¨é”™è¯¯è·¯å¾„æˆ–æ­£å¸¸é€€å‡ºæ—¶æœªæ­£ç¡®å…³é—­ã€‚

**é£é™©ç­‰çº§**ï¼šğŸ”´ ä¸¥é‡

**é—®é¢˜ç¤ºä¾‹**ï¼š
```c
int32_t ProcessConnection(int32_t connFd) {
    char *buffer = SoftBusMalloc(BUFFER_SIZE);
    if (buffer == NULL) {
        return SOFTBUS_ERR;  // âŒ æœªå…³é—­ connFd
    }

    int32_t ret = recv(connFd, buffer, BUFFER_SIZE, 0);
    if (ret < 0) {
        SoftBusFree(buffer);
        return SOFTBUS_ERR;  // âŒ æœªå…³é—­ connFd
    }

    // å¤„ç†æ•°æ®...

    SoftBusFree(buffer);
    // âŒ å¿˜è®°å…³é—­ connFd
    return SOFTBUS_OK;
}
```

**ä¿®å¤æ–¹æ¡ˆ**ï¼š
```c
int32_t ProcessConnection(int32_t connFd) {
    char *buffer = SoftBusMalloc(BUFFER_SIZE);
    if (buffer == NULL) {
        SoftBusSocketClose(connFd);  // âœ… å…³é—­ fd
        return SOFTBUS_ERR;
    }

    int32_t ret = recv(connFd, buffer, BUFFER_SIZE, 0);
    if (ret < 0) {
        SoftBusFree(buffer);
        SoftBusSocketClose(connFd);  // âœ… å…³é—­ fd
        return SOFTBUS_ERR;
    }

    // å¤„ç†æ•°æ®...

    SoftBusFree(buffer);
    SoftBusSocketClose(connFd);  // âœ… å…³é—­ fd
    return SOFTBUS_OK;
}
```

**æ£€æŸ¥è¦ç‚¹**ï¼š
- å‡½æ•°æ¥æ”¶çš„ fd å‚æ•°ï¼Œå¦‚æœä¸å†ä½¿ç”¨åº”å…³é—­
- æ£€æŸ¥æ‰€æœ‰è¿”å›è·¯å¾„
- æ³¨æ„ fd çš„æ‰€æœ‰æƒè½¬ç§»

---

## 7. å†…å­˜ç®¡ç†æ£€æŸ¥

### è§„åˆ™ 7.1: å†…å­˜ç”³è¯·å‰å¤§å°åˆæ³•æ€§æ ¡éªŒ

**é—®é¢˜æè¿°**ï¼š
malloc/calloc çš„ size å‚æ•°æœªæ ¡éªŒï¼Œå¯èƒ½å¯¼è‡´åˆ†é…è¿‡å¤§æˆ–æ•´æ•°æº¢å‡ºã€‚

**é£é™©ç­‰çº§**ï¼šğŸ”´ ä¸¥é‡

**é—®é¢˜ç¤ºä¾‹**ï¼š
```c
int32_t ProcessData(uint32_t count, uint32_t itemSize) {
    // âŒ æœªæ ¡éªŒå¤§å°
    uint32_t totalSize = count * itemSize;  // å¯èƒ½æº¢å‡º
    char *buffer = SoftBusMalloc(totalSize);
    if (buffer == NULL) {
        return SOFTBUS_ERR;
    }
    // ...
}

int32_t AllocateBuffer(uint32_t size) {
    // âŒ size å¯èƒ½éå¸¸å¤§
    return SoftBusMalloc(size);
}
```

**ä¿®å¤æ–¹æ¡ˆ**ï¼š
```c
#define MAX_ALLOC_SIZE (10 * 1024 * 1024)  // 10MB

int32_t ProcessData(uint32_t count, uint32_t itemSize) {
    // âœ… æ ¡éªŒå‚æ•°
    if (count == 0 || itemSize == 0) {
        HILOG_ERROR("Invalid count or itemSize");
        return SOFTBUS_INVALID_PARAM;
    }

    // âœ… æ£€æŸ¥ä¹˜æ³•æº¢å‡º
    if (count > MAX_ALLOC_SIZE / itemSize) {
        HILOG_ERROR("Size overflow: count=%{public}u, itemSize=%{public}u", count, itemSize);
        return SOFTBUS_INVALID_PARAM;
    }

    uint32_t totalSize = count * itemSize;
    char *buffer = SoftBusMalloc(totalSize);
    if (buffer == NULL) {
        return SOFTBUS_ERR;
    }
    // ...
}

int32_t AllocateBuffer(uint32_t size) {
    // âœ… é™åˆ¶æœ€å¤§åˆ†é…å¤§å°
    if (size > MAX_ALLOC_SIZE) {
        HILOG_ERROR("Size too large: %{public}u", size);
        return NULL;
    }

    return SoftBusMalloc(size);
}
```

**æ£€æŸ¥è¦ç‚¹**ï¼š
- æ£€æŸ¥ size æ˜¯å¦ä¸º 0
- æ£€æŸ¥ size æ˜¯å¦è¶…è¿‡åˆç†ä¸Šé™
- æ£€æŸ¥ä¹˜æ³•è¿ç®—æ˜¯å¦æº¢å‡º
- å®šä¹‰å…¨å±€ MAX_ALLOC_SIZE å¸¸é‡

---

### è§„åˆ™ 7.2: SoftBusMalloc/SoftBusCalloc ä¸ SoftBusFree æˆå¯¹ä½¿ç”¨

**é—®é¢˜æè¿°**ï¼š
malloc å’Œ free ä¸æˆå¯¹ï¼Œå¯¼è‡´å†…å­˜æ³„æ¼ã€‚

**é£é™©ç­‰çº§**ï¼šğŸ”´ ä¸¥é‡

**é—®é¢˜ç¤ºä¾‹**ï¼š
```c
int32_t ParseConfig(const char *jsonStr) {
    cJSON *root = cJSON_Parse(jsonStr);
    if (root == NULL) {
        return SOFTBUS_ERR;
    }

    cJSON *item = cJSON_GetObjectItem(root, "key");
    if (item == NULL) {
        // âŒ å¿˜è®°åˆ é™¤ root
        return SOFTBUS_ERR;
    }

    // å¤„ç† item...

    // âŒ å¿˜è®°åˆ é™¤ root
    return SOFTBUS_OK;
}
```

**ä¿®å¤æ–¹æ¡ˆ**ï¼š
```c
int32_t ParseConfig(const char *jsonStr) {
    cJSON *root = cJSON_Parse(jsonStr);
    if (root == NULL) {
        return SOFTBUS_ERR;
    }

    cJSON *item = cJSON_GetObjectItem(root, "key");
    if (item == NULL) {
        cJSON_Delete(root);  // âœ… é‡Šæ”¾èµ„æº
        return SOFTBUS_ERR;
    }

    // å¤„ç† item...

    cJSON_Delete(root);  // âœ… é‡Šæ”¾èµ„æº
    root = NULL;  // âœ… ç½®ç©º
    return SOFTBUS_OK;
}
```

**æ£€æŸ¥è¦ç‚¹**ï¼š
- æ¯ä¸ª malloc å¿…é¡»æœ‰å¯¹åº”çš„ free
- æ£€æŸ¥æ‰€æœ‰è¿”å›è·¯å¾„
- è·¨æ–‡ä»¶è¿½è¸ª malloc/free çš„é…å¯¹

---

### è§„åˆ™ 7.3: new ä¸ delete æˆå¯¹ä½¿ç”¨

**é—®é¢˜æè¿°**ï¼š
C++ çš„ new å’Œ delete ä¸æˆå¯¹ï¼Œæˆ– new[] ç”¨ delete åˆ é™¤ã€‚

**é£é™©ç­‰çº§**ï¼šğŸ”´ ä¸¥é‡

**é—®é¢˜ç¤ºä¾‹**ï¼š
```c++
class MessageHandler {
public:
    MessageHandler() {
        buffer_ = new char[1024];  // new[]
    }

    ~MessageHandler() {
        delete buffer_;  // âŒ åº”è¯¥ç”¨ delete[]
    }

private:
    char *buffer_;
};
```

**ä¿®å¤æ–¹æ¡ˆ**ï¼š
```c++
class MessageHandler {
public:
    MessageHandler() {
        buffer_ = new char[1024];
    }

    ~MessageHandler() {
        delete[] buffer_;  // âœ… ä½¿ç”¨ delete[]
        buffer_ = nullptr;
    }

private:
    char *buffer_;
};

// æˆ–è€…ä½¿ç”¨æ ‡å‡†å®¹å™¨
class MessageHandler {
public:
    std::vector<char> buffer_;  // âœ… è‡ªåŠ¨ç®¡ç†å†…å­˜
};
```

**æ£€æŸ¥è¦ç‚¹**ï¼š
- new é… deleteï¼Œnew[] é… delete[]
- ä¼˜å…ˆä½¿ç”¨ std::vectorã€std::string ç­‰æ ‡å‡†å®¹å™¨
- ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆï¼ˆstd::unique_ptr, std::shared_ptrï¼‰

---

### è§„åˆ™ 7.4: å†…å­˜ç”³è¯·ååˆ¤ç©º

**é—®é¢˜æè¿°**ï¼š
malloc/calloc è¿”å›å€¼æœªåˆ¤ç©ºå°±ç›´æ¥ä½¿ç”¨ã€‚

**é£é™©ç­‰çº§**ï¼šğŸ”´ ä¸¥é‡

**é—®é¢˜ç¤ºä¾‹**ï¼š
```c
int32_t ProcessData(void) {
    char *buffer = SoftBusMalloc(1024);
    // âŒ æœªåˆ¤ç©º

    strcpy(buffer, "data");  // å¯èƒ½å´©æºƒ
    return SOFTBUS_OK;
}
```

**ä¿®å¤æ–¹æ¡ˆ**ï¼š
```c
int32_t ProcessData(void) {
    char *buffer = SoftBusMalloc(1024);
    if (buffer == NULL) {  // âœ… åˆ¤ç©º
        HILOG_ERROR("Malloc failed");
        return SOFTBUS_MALLOC_ERR;
    }

    strcpy(buffer, "data");
    // ä½¿ç”¨ buffer...

    SoftBusFree(buffer);
    return SOFTBUS_OK;
}
```

**æ£€æŸ¥è¦ç‚¹**ï¼š
- æ‰€æœ‰ malloc/calloc ç»“æœå¿…é¡»åˆ¤ç©º
- new æ“ä½œç¬¦åœ¨ C++ ä¸­æŠ›å‡ºå¼‚å¸¸ï¼Œä¸éœ€è¦åˆ¤ç©ºï¼ˆä½†å»ºè®®æ£€æŸ¥ std::bad_allocï¼‰

---

### è§„åˆ™ 7.5: å…¨å±€å˜é‡é‡Šæ”¾åç½®ç©º

**é—®é¢˜æè¿°**ï¼š
å…¨å±€å˜é‡ free/delete åæœªç½®ç©ºï¼Œå¯èƒ½å¯¼è‡´åŒé‡é‡Šæ”¾ã€‚

**é£é™©ç­‰çº§**ï¼šğŸŸ¡ è­¦å‘Š

**é—®é¢˜ç¤ºä¾‹**ï¼š
```c
static char *g_buffer = NULL;

int32_t InitBuffer(void) {
    g_buffer = SoftBusMalloc(1024);
    if (g_buffer == NULL) {
        return SOFTBUS_ERR;
    }
    return SOFTBUS_OK;
}

int32_t CleanupBuffer(void) {
    if (g_buffer != NULL) {
        SoftBusFree(g_buffer);
        // âŒ æœªç½®ç©º
    }
    return SOFTBUS_OK;
}

int32_t ReinitBuffer(void) {
    // g_buffer ä¸æ˜¯ NULLï¼Œå¯èƒ½é‡å¤é‡Šæ”¾æˆ–ä½¿ç”¨é‡æŒ‡é’ˆ
    SoftBusFree(g_buffer);  // âŒ å¯èƒ½ double free
    g_buffer = SoftBusMalloc(1024);
    return SOFTBUS_OK;
}
```

**ä¿®å¤æ–¹æ¡ˆ**ï¼š
```c
static char *g_buffer = NULL;

int32_t InitBuffer(void) {
    if (g_buffer != NULL) {  // âœ… æ£€æŸ¥æ˜¯å¦å·²åˆå§‹åŒ–
        HILOG_WARN("Buffer already initialized");
        return SOFTBUS_OK;
    }

    g_buffer = SoftBusMalloc(1024);
    if (g_buffer == NULL) {
        return SOFTBUS_ERR;
    }
    return SOFTBUS_OK;
}

int32_t CleanupBuffer(void) {
    if (g_buffer != NULL) {
        SoftBusFree(g_buffer);
        g_buffer = NULL;  // âœ… é‡Šæ”¾åç½®ç©º
    }
    return SOFTBUS_OK;
}

int32_t ReinitBuffer(void) {
    CleanupBuffer();  // âœ… å…ˆæ¸…ç†

    g_buffer = SoftBusMalloc(1024);
    if (g_buffer == NULL) {
        return SOFTBUS_ERR;
    }
    return SOFTBUS_OK;
}
```

**æ£€æŸ¥è¦ç‚¹**ï¼š
- å…¨å±€å˜é‡ free/delete åå¿…é¡»ç½®ç©º
- é‡æ–°åˆå§‹åŒ–å‰å…ˆæ£€æŸ¥å’Œæ¸…ç†
- é¿å…åŒé‡é‡Šæ”¾

---

### è§„åˆ™ 7.6: å¾ªç¯ä½“é‡Šæ”¾åç½®ç©º

**é—®é¢˜æè¿°**ï¼š
å¾ªç¯ä¸­é‡Šæ”¾èµ„æºåæœªç½®ç©ºï¼Œä¸‹æ¬¡å¾ªç¯å¯èƒ½åŒé‡é‡Šæ”¾ã€‚

**é£é™©ç­‰çº§**ï¼šğŸ”´ ä¸¥é‡

**é—®é¢˜ç¤ºä¾‹**ï¼š
```c
int32_t ProcessMultipleItems(void) {
    char *buffer = NULL;

    for (int i = 0; i < count; i++) {
        buffer = SoftBusMalloc(1024);
        if (buffer == NULL) {
            return SOFTBUS_ERR;
        }

        // å¤„ç†æ•°æ®...

        SoftBusFree(buffer);
        // âŒ æœªç½®ç©ºï¼Œä¸‹æ¬¡å¾ªç¯å¯èƒ½å‡ºé”™
    }

    return SOFTBUS_OK;
}
```

**ä¿®å¤æ–¹æ¡ˆ**ï¼š
```c
int32_t ProcessMultipleItems(void) {
    char *buffer = NULL;

    for (int i = 0; i < count; i++) {
        buffer = SoftBusMalloc(1024);
        if (buffer == NULL) {
            return SOFTBUS_ERR;
        }

        // å¤„ç†æ•°æ®...

        SoftBusFree(buffer);
        buffer = NULL;  // âœ… é‡Šæ”¾åç½®ç©º
    }

    return SOFTBUS_OK;
}
```

**æ£€æŸ¥è¦ç‚¹**ï¼š
- å¾ªç¯ä¸­çš„ free/delete åå¿…é¡»ç½®ç©º
- é¿å…ä¸‹æ¬¡å¾ªç¯ä½¿ç”¨é‡æŒ‡é’ˆ

---

### è§„åˆ™ 7.7-7.11: ç‰¹å®šèµ„æºç®¡ç†

**é—®é¢˜æè¿°**ï¼š
ç‰¹å®šèµ„æºï¼ˆæ­£åˆ™è¡¨è¾¾å¼ã€cJSONã€JSONç­‰ï¼‰çš„åˆ›å»ºå’Œé‡Šæ”¾ä¸æˆå¯¹ã€‚

**é£é™©ç­‰çº§**ï¼šğŸ”´ ä¸¥é‡

**é—®é¢˜ç¤ºä¾‹**ï¼š
```c
// regcomp / regfree
regex_t reg;
if (regcomp(&reg, pattern, REG_EXTENDED) != 0) {
    return SOFTBUS_ERR;
}
// ä½¿ç”¨ reg...
// âŒ å¿˜è®° regfree(&reg)

// cJSON_Parse / cJSON_Delete
cJSON *root = cJSON_Parse(jsonStr);
// âŒ å¿˜è®° cJSON_Delete(root)

// JSON_PrintUnformatted / JSON_Free
char *str = JSON_PrintUnformatted(root);
// âŒ å¿˜è®° JSON_Free(str)

// Anonymize / AnonymizeFree
char *anon = Anonymize(udid);
// âŒ å¿˜è®° AnonymizeFree(anon)

// strdup
char *copy = strdup(original);
// âŒ å¿˜è®° free(copy)

// realpath
char *resolved = realpath(path, NULL);
// âŒ å¿˜è®° free(resolved)
```

**ä¿®å¤æ–¹æ¡ˆ**ï¼š
```c
// regcomp / regfree
regex_t reg;
if (regcomp(&reg, pattern, REG_EXTENDED) != 0) {
    return SOFTBUS_ERR;
}
// ä½¿ç”¨ reg...
regfree(&reg);  // âœ… é‡Šæ”¾
memset(&reg, 0, sizeof(reg));  // âœ… æ¸…é›¶

// cJSON_Parse / cJSON_Delete
cJSON *root = cJSON_Parse(jsonStr);
if (root != NULL) {
    // ä½¿ç”¨ root...
    cJSON_Delete(root);  // âœ… é‡Šæ”¾
    root = NULL;
}

// JSON_PrintUnformatted / JSON_Free
char *str = JSON_PrintUnformatted(root);
if (str != NULL) {
    // ä½¿ç”¨ str...
    JSON_Free(str);  // âœ… é‡Šæ”¾
    str = NULL;
}

// Anonymize / AnonymizeFree
char *anon = Anonymize(udid);
if (anon != NULL) {
    // ä½¿ç”¨ anon...
    AnonymizeFree(anon);  // âœ… é‡Šæ”¾
    anon = NULL;
}

// strdup
char *copy = strdup(original);
if (copy != NULL) {
    // ä½¿ç”¨ copy...
    free(copy);  // âœ… é‡Šæ”¾
    copy = NULL;
}

// realpath
char *resolved = realpath(path, NULL);
if (resolved != NULL) {
    // ä½¿ç”¨ resolved...
    free(resolved);  // âœ… é‡Šæ”¾
    resolved = NULL;
}
```

**æ£€æŸ¥è¦ç‚¹**ï¼š
- æ¯ä¸ªåˆ›å»ºå‡½æ•°éƒ½æœ‰å¯¹åº”çš„é‡Šæ”¾å‡½æ•°
- æ£€æŸ¥å‡½æ•°æ–‡æ¡£ï¼Œäº†è§£é‡Šæ”¾å‡½æ•°åç§°
- ä½¿ç”¨ RAII æ¨¡å¼æˆ– goto ç»Ÿä¸€æ¸…ç†

---

## 8. æ•æ„Ÿä¿¡æ¯æ£€æŸ¥

### è§„åˆ™ 8.1: ç¦æ­¢æ‰“å°å¯†é’¥ã€æ–‡ä»¶è·¯å¾„ã€å†…å­˜åœ°å€ã€udidhashã€è®¾å¤‡åç§°ã€è´¦å· id

**é—®é¢˜æè¿°**ï¼š
æ—¥å¿—ä¸­è¾“å‡ºæ•æ„Ÿä¿¡æ¯ï¼Œå¯èƒ½å¯¼è‡´å®‰å…¨æ¼æ´ã€‚

**é£é™©ç­‰çº§**ï¼šğŸ”´ ä¸¥é‡

**é—®é¢˜ç¤ºä¾‹**ï¼š
```c
int32_t ConnectDevice(const char *networkId, const char *udid,
                      const char *key) {
    HILOG_INFO("Connecting to device:");
    HILOG_INFO("  networkId=%{public}s", networkId);  // âŒ æ‰“å°ç½‘ç»œID
    HILOG_INFO("  udid=%{public}s", udid);            // âŒ æ‰“å°UDID
    HILOG_INFO("  key=%{public}s", key);              // âŒ æ‰“å°å¯†é’¥
    HILOG_INFO("  key addr=%{public}p", key);         // âŒ æ‰“å°åœ°å€
    return SOFTBUS_OK;
}

int32_t LoadConfig(const char *configPath) {
    HILOG_INFO("Loading config from: %{public}s", configPath);  // âŒ æ‰“å°è·¯å¾„
    // ...
}
```

**ä¿®å¤æ–¹æ¡ˆ**ï¼š
```c
int32_t ConnectDevice(const char *networkId, const char *udid,
                      const char *key) {
    HILOG_INFO("Connecting to device:");
    HILOG_INFO("  networkId=%{private}s", networkId);  // âœ… åŒ¿ååŒ–
    HILOG_INFO("  udid=%{private}s", udid);            // âœ… åŒ¿ååŒ–
    // âœ… ä¸æ‰“å°å¯†é’¥
    HILOG_INFO("  key length=%{public}zu", strlen(key));
    // ...
}

int32_t LoadConfig(const char *configPath) {
    // âœ… ä¸æ‰“å°å®Œæ•´è·¯å¾„
    const char *filename = strrchr(configPath, '/');
    if (filename != NULL) {
        filename++;  // è·³è¿‡ '/'
    } else {
        filename = configPath;
    }
    HILOG_INFO("Loading config: %{public}s", filename);
    // ...
}
```

**æ£€æŸ¥è¦ç‚¹**ï¼š
- ç¦æ­¢ä½¿ç”¨ `%{public}s` æ‰“å°æ•æ„Ÿå­—ç¬¦ä¸²
- ä½¿ç”¨ `%{private}s` åŒ¿ååŒ–
- å¯†é’¥ã€å¯†ç ã€token ç»ä¸æ‰“å°
- æ–‡ä»¶è·¯å¾„åªæ‰“å°æ–‡ä»¶å
- å†…å­˜åœ°å€ç»ä¸æ‰“å°

---

### è§„åˆ™ 8.2: å †æ ˆå¯†é’¥ä½¿ç”¨åæ˜¯å¦æ¸…é›¶

**é—®é¢˜æè¿°**ï¼š
æ ˆä¸Šçš„å¯†é’¥ä½¿ç”¨åæœªæ¸…é›¶ï¼Œå¯èƒ½è¢«æ”»å‡»è€…è¯»å–ã€‚

**é£é™©ç­‰çº§**ï¼šğŸ”´ ä¸¥é‡

**é—®é¢˜ç¤ºä¾‹**ï¼š
```c
int32_t EncryptData(const char *input, char *output) {
    char sessionKey[32];  // æ ˆä¸Šå¯†é’¥

    GenerateSessionKey(sessionKey, 32);

    // ä½¿ç”¨å¯†é’¥åŠ å¯†...
    EncryptWithKey(input, output, sessionKey);

    // âŒ å¿˜è®°æ¸…é›¶å¯†é’¥
    return SOFTBUS_OK;
}
```

**ä¿®å¤æ–¹æ¡ˆ**ï¼š
```c
int32_t EncryptData(const char *input, char *output) {
    char sessionKey[32];

    GenerateSessionKey(sessionKey, 32);

    // ä½¿ç”¨å¯†é’¥åŠ å¯†...
    EncryptWithKey(input, output, sessionKey);

    // âœ… ä½¿ç”¨åç«‹å³æ¸…é›¶
    memset(sessionKey, 0, sizeof(sessionKey));

    return SOFTBUS_OK;
}
```

**æ£€æŸ¥è¦ç‚¹**ï¼š
- æ ˆä¸Šçš„å¯†é’¥ã€å¯†ç ä½¿ç”¨åå¿…é¡»æ¸…é›¶
- ä½¿ç”¨ memset_s æˆ–ç±»ä¼¼å®‰å…¨å‡½æ•°ï¼ˆå¦‚æœå¯ç”¨ï¼‰
- æ³¨æ„ç¼–è¯‘å™¨ä¼˜åŒ–å¯èƒ½ç§»é™¤ memsetï¼Œä½¿ç”¨ volatile æˆ–ç‰¹æ®Šå‡½æ•°

---

### è§„åˆ™ 8.3: udid/networkid/uuid/ip/mac ç­‰åŒ¿ååŒ–æ‰“å°

**é—®é¢˜æè¿°**ï¼š
è®¾å¤‡æ ‡è¯†ç¬¦æœªåŒ¿ååŒ–æ‰“å°ï¼Œæ³„éœ²ç”¨æˆ·éšç§ã€‚

**é£é™©ç­‰çº§**ï¼šğŸ”´ ä¸¥é‡

**é—®é¢˜ç¤ºä¾‹**ï¼š
```c
int32_t OnDeviceConnected(const char *networkId, const char *udid,
                          const char *ip, const char *mac) {
    HILOG_INFO("Device connected:");
    HILOG_INFO("  networkId=%{public}s", networkId);  // âŒ
    HILOG_INFO("  udid=%{public}s", udid);            // âŒ
    HILOG_INFO("  ip=%{public}s", ip);                // âŒ
    HILOG_INFO("  mac=%{public}s", mac);              // âŒ
    return SOFTBUS_OK;
}
```

**ä¿®å¤æ–¹æ¡ˆ**ï¼š
```c
int32_t OnDeviceConnected(const char *networkId, const char *udid,
                          const char *ip, const char *mac) {
    HILOG_INFO("Device connected:");
    HILOG_INFO("  networkId=%{private}s", networkId);  // âœ… åŒ¿ååŒ–
    HILOG_INFO("  udid=%{private}s", udid);            // âœ… åŒ¿ååŒ–

    // âœ… IP åœ°å€éƒ¨åˆ†éšè—ï¼ˆåªæ˜¾ç¤ºå‰ä¸¤æ®µï¼‰
    char maskedIp[32];
    MaskIpAddress(ip, maskedIp, sizeof(maskedIp));
    HILOG_INFO("  ip=%{public}s", maskedIp);

    // âœ… MAC åœ°å€éƒ¨åˆ†éšè—ï¼ˆåªæ˜¾ç¤ºå‰åŠéƒ¨åˆ†ï¼‰
    HILOG_INFO("  mac=%{private}s", mac);  // æˆ–è€…å®Œå…¨åŒ¿ååŒ–

    return SOFTBUS_OK;
}
```

**æ£€æŸ¥è¦ç‚¹**ï¼š
- æ‰€æœ‰è®¾å¤‡æ ‡è¯†ç¬¦ä½¿ç”¨ `%{private}s`
- IP åœ°å€å¯ä»¥éƒ¨åˆ†éšè—ï¼ˆå¦‚ 192.168.xxx.xxxï¼‰
- MAC åœ°å€å¯ä»¥éƒ¨åˆ†éšè—ï¼ˆå¦‚ aa:bb:cc:xx:xx:xxï¼‰
- UUID/UDID å®Œå…¨åŒ¿ååŒ–

---

## 9. æ•´æ•°è¿ç®—æ£€æŸ¥

### è§„åˆ™ 9.1: æ•´æ•°æº¢å‡ºã€åè½¬ã€é™¤0é£é™©

**é—®é¢˜æè¿°**ï¼š
æ•´æ•°è¿ç®—æœªæ£€æŸ¥æº¢å‡ºã€ç¬¦å·åè½¬æˆ–é™¤é›¶ã€‚

**é£é™©ç­‰çº§**ï¼šğŸ”´ ä¸¥é‡

**é—®é¢˜ç¤ºä¾‹**ï¼š
```c
int32_t AllocateBuffer(uint32_t count, uint32_t size) {
    // âŒ å¯èƒ½æº¢å‡º
    uint32_t total = count * size;
    return SoftBusMalloc(total);
}

int32_t CalculateOffset(int32_t base, int32_t offset) {
    // âŒ å¯èƒ½åè½¬
    int32_t result = base + offset;
    if (result < 0) {
        return SOFTBUS_ERR;
    }
    return result;
}

int32_t DivideData(int32_t a, int32_t b) {
    // âŒ å¯èƒ½é™¤é›¶
    return a / b;
}
```

**ä¿®å¤æ–¹æ¡ˆ**ï¼š
```c
int32_t AllocateBuffer(uint32_t count, uint32_t size) {
    // âœ… æ£€æŸ¥ä¹˜æ³•æº¢å‡º
    if (count != 0 && size > UINT32_MAX / count) {
        HILOG_ERROR("Integer overflow: count=%{public}u, size=%{public}u",
                    count, size);
        return NULL;
    }
    uint32_t total = count * size;

    // âœ… æ£€æŸ¥å¤§å°ä¸Šé™
    if (total > MAX_ALLOC_SIZE) {
        HILOG_ERROR("Allocation too large: %{public}u", total);
        return NULL;
    }

    return SoftBusMalloc(total);
}

int32_t CalculateOffset(int32_t base, int32_t offset) {
    // âœ… æ£€æŸ¥åŠ æ³•æº¢å‡º
    if ((offset > 0 && base > INT32_MAX - offset) ||
        (offset < 0 && base < INT32_MIN - offset)) {
        HILOG_ERROR("Integer overflow: base=%{public}d, offset=%{public}d",
                    base, offset);
        return SOFTBUS_ERR;
    }
    int32_t result = base + offset;

    if (result < 0) {
        return SOFTBUS_ERR;
    }
    return result;
}

int32_t DivideData(int32_t a, int32_t b) {
    // âœ… æ£€æŸ¥é™¤é›¶
    if (b == 0) {
        HILOG_ERROR("Division by zero");
        return SOFTBUS_ERR;
    }

    // âœ… æ£€æŸ¥ INT_MIN / -1 æº¢å‡º
    if (a == INT32_MIN && b == -1) {
        HILOG_ERROR("Integer overflow in division");
        return SOFTBUS_ERR;
    }

    return a / b;
}
```

**æ£€æŸ¥è¦ç‚¹**ï¼š
- åŠ æ³•ï¼šæ£€æŸ¥ `a + b` æ˜¯å¦æº¢å‡º
- å‡æ³•ï¼šæ£€æŸ¥ `a - b` æ˜¯å¦æº¢å‡º
- ä¹˜æ³•ï¼šæ£€æŸ¥ `a * b` æ˜¯å¦æº¢å‡º
- é™¤æ³•ï¼šæ£€æŸ¥é™¤æ•°æ˜¯å¦ä¸º 0ï¼Œ`INT_MIN / -1` ç‰¹æ®Šæƒ…å†µ
- ä½¿ç”¨ INT_MAXã€INT32_MAX ç­‰å¸¸é‡

---

### è§„åˆ™ 9.2: æœ‰ç¬¦å·æ•´æ•°ä½æ“ä½œç¬¦è¿ç®—

**é—®é¢˜æè¿°**ï¼š
å¯¹æœ‰ç¬¦å·æ•´æ•°è¿›è¡Œä½è¿ç®—ï¼ˆ`&`, `|`, `^`, `~`, `<<`, `>>`ï¼‰æ˜¯æœªå®šä¹‰è¡Œä¸ºã€‚

**é£é™©ç­‰çº§**ï¼šğŸ”´ ä¸¥é‡

**é—®é¢˜ç¤ºä¾‹**ï¼š
```c
int32_t SetFlag(int32_t value, int32_t flag) {
    // âŒ å¯¹æœ‰ç¬¦å·æ•´æ•°è¿›è¡Œä½è¿ç®—
    return value | flag;
}

int32_t ClearFlag(int32_t value, int32_t flag) {
    // âŒ å¯¹æœ‰ç¬¦å·æ•´æ•°è¿›è¡Œä½è¿ç®—
    return value & ~flag;
}

int32_t ShiftValue(int32_t value, int32_t shift) {
    // âŒ å¯¹æœ‰ç¬¦å·æ•´æ•°è¿›è¡Œç§»ä½
    return value << shift;
}
```

**ä¿®å¤æ–¹æ¡ˆ**ï¼š
```c
uint32_t SetFlag(uint32_t value, uint32_t flag) {
    // âœ… ä½¿ç”¨æ— ç¬¦å·æ•´æ•°
    return value | flag;
}

uint32_t ClearFlag(uint32_t value, uint32_t flag) {
    // âœ… ä½¿ç”¨æ— ç¬¦å·æ•´æ•°
    return value & ~flag;
}

uint32_t ShiftValue(uint32_t value, uint32_t shift) {
    // âœ… ä½¿ç”¨æ— ç¬¦å·æ•´æ•°
    if (shift >= 32) {
        return 0;
    }
    return value << shift;
}
```

**æ£€æŸ¥è¦ç‚¹**ï¼š
- ä½è¿ç®—æ“ä½œæ•°åº”è¯¥æ˜¯æ— ç¬¦å·ç±»å‹
- ç§»ä½æ“ä½œæ£€æŸ¥ç§»ä½æ•°é‡ï¼ˆ< 32ï¼‰
- ä½¿ç”¨ `uint32_t`, `uint64_t` ç­‰æ— ç¬¦å·ç±»å‹
- å¦‚æœå¿…é¡»ç”¨æœ‰ç¬¦å·ï¼Œå…ˆè½¬æ¢ä¸ºæ— ç¬¦å·ï¼Œè¿ç®—åå†è½¬å›

---

## 10. å¾ªç¯å˜é‡æ£€æŸ¥

### è§„åˆ™ 10.1: æ— ç¬¦å·æ•°æ­»å¾ªç¯

**é—®é¢˜æè¿°**ï¼š
ä½¿ç”¨æ— ç¬¦å·æ•°ä½œä¸ºå¾ªç¯å˜é‡è¿›è¡Œé€’å‡ï¼Œå¯¼è‡´æ­»å¾ªç¯ã€‚

**é£é™©ç­‰çº§**ï¼šğŸ”´ ä¸¥é‡

**é—®é¢˜ç¤ºä¾‹**ï¼š
```c
void ProcessArray(uint32_t count) {
    // âŒ æ°¸è¿œä¸ä¼šé€€å‡ºï¼ˆi >= 0 æ°¸è¿œä¸ºçœŸï¼‰
    for (uint32_t i = count; i >= 0; i--) {
        // å¤„ç†æ•°æ®
    }
}

void ReverseArray(int *arr, uint32_t len) {
    // âŒ æ­»å¾ªç¯
    for (uint32_t i = len - 1; i >= 0; i--) {
        // äº¤æ¢å…ƒç´ 
    }
}
```

**ä¿®å¤æ–¹æ¡ˆ**ï¼š
```c
void ProcessArray(uint32_t count) {
    // âœ… æ–¹æ¡ˆ1ï¼šä½¿ç”¨æœ‰ç¬¦å·æ•°
    for (int32_t i = (int32_t)count - 1; i >= 0; i--) {
        // å¤„ç†æ•°æ®
    }

    // âœ… æ–¹æ¡ˆ2ï¼šåå‘é€’å¢
    for (uint32_t i = 0; i < count; i++) {
        uint32_t idx = count - 1 - i;
        // å¤„ç† arr[idx]
    }

    // âœ… æ–¹æ¡ˆ3ï¼šä½¿ç”¨ while å¾ªç¯
    uint32_t i = count;
    while (i > 0) {
        i--;
        // å¤„ç† arr[i]
    }
}
```

**æ£€æŸ¥è¦ç‚¹**ï¼š
- æœç´¢ `for (uint.*i = .*; i >= 0; i--)` æ¨¡å¼
- æ— ç¬¦å·æ•°æ°¸è¿œ >= 0
- é€’å‡å¾ªç¯ä½¿ç”¨æœ‰ç¬¦å·æ•°æˆ–æ”¹å˜å¾ªç¯ç»“æ„

---

### è§„åˆ™ 10.2: å¤–éƒ¨æ•°æ®æ§åˆ¶å¾ªç¯çš„åˆæ³•æ€§æ ¡éªŒ

**é—®é¢˜æè¿°**ï¼š
å¾ªç¯æ¬¡æ•°ç”±å¤–éƒ¨è¾“å…¥æ§åˆ¶ï¼Œæœªæ ¡éªŒåˆæ³•æ€§ã€‚

**é£é™©ç­‰çº§**ï¼šğŸ”´ ä¸¥é‡

**é—®é¢˜ç¤ºä¾‹**ï¼š
```c
int32_t ProcessNetworkData(const char *data, uint32_t len) {
    // âŒ ç›´æ¥ä½¿ç”¨å¤–éƒ¨è¾“å…¥ä½œä¸ºå¾ªç¯æ¬¡æ•°
    uint32_t count = *(uint32_t *)data;
    for (uint32_t i = 0; i < count; i++) {
        // å¤„ç†æ•°æ®
    }
}

int32_t ParseUserFile(const char *filename) {
    // âŒ ç”¨æˆ·æä¾›çš„è¿­ä»£æ¬¡æ•°
    uint32_t repeatCount = GetUserRepeatCount();
    for (uint32_t i = 0; i < repeatCount; i++) {
        ProcessFile(filename);
    }
}
```

**ä¿®å¤æ–¹æ¡ˆ**ï¼š
```c
#define MAX_ITERATIONS 10000

int32_t ProcessNetworkData(const char *data, uint32_t len) {
    if (len < sizeof(uint32_t)) {
        return SOFTBUS_ERR;
    }

    // âœ… æ ¡éªŒå¾ªç¯æ¬¡æ•°ä¸Šé™
    uint32_t count = *(uint32_t *)data;
    if (count > MAX_ITERATIONS) {
        HILOG_ERROR("Invalid iteration count: %{public}u", count);
        return SOFTBUS_INVALID_PARAM;
    }

    for (uint32_t i = 0; i < count; i++) {
        // å¤„ç†æ•°æ®
    }
}

int32_t ParseUserFile(const char *filename) {
    // âœ… é™åˆ¶ç”¨æˆ·æä¾›çš„è¿­ä»£æ¬¡æ•°
    uint32_t repeatCount = GetUserRepeatCount();
    if (repeatCount > MAX_ITERATIONS) {
        HILOG_ERROR("Invalid repeat count: %{public}u", repeatCount);
        return SOFTBUS_INVALID_PARAM;
    }

    for (uint32_t i = 0; i < repeatCount; i++) {
        ProcessFile(filename);
    }
}
```

**æ£€æŸ¥è¦ç‚¹**ï¼š
- æ‰€æœ‰å¤–éƒ¨è¾“å…¥çš„å¾ªç¯æ¬¡æ•°å¿…é¡»æ ¡éªŒä¸Šé™
- å®šä¹‰åˆç†çš„ MAX_ITERATIONS å¸¸é‡
- é˜²æ­¢ DoS æ”»å‡»ï¼ˆè¶…å¤§å¾ªç¯æ¬¡æ•°ï¼‰

---

## 11. å®‰å…¨å‡½æ•°æ£€æŸ¥

### è§„åˆ™ 11.1: å®‰å…¨å‡½æ•°è¿”å›å€¼å¤„ç†

**é—®é¢˜æè¿°**ï¼š
å®‰å…¨å‡½æ•°ï¼ˆmemcpy_s, strcpy_s ç­‰ï¼‰è¿”å›å€¼æœªæ£€æŸ¥ã€‚

**é£é™©ç­‰çº§**ï¼šğŸ”´ ä¸¥é‡

**é—®é¢˜ç¤ºä¾‹**ï¼š
```c
int32_t CopyData(const char *src, char *dst, uint32_t dstSize) {
    // âŒ æœªæ£€æŸ¥è¿”å›å€¼
    memcpy_s(dst, dstSize, src, strlen(src));
    strcpy_s(dst, dstSize, src);
    return SOFTBUS_OK;
}
```

**ä¿®å¤æ–¹æ¡ˆ**ï¼š
```c
int32_t CopyData(const char *src, char *dst, uint32_t dstSize) {
    errno_t err;

    // âœ… æ£€æŸ¥è¿”å›å€¼
    err = memcpy_s(dst, dstSize, src, strlen(src));
    if (err != 0) {
        HILOG_ERROR("memcpy_s failed: %{public}d", err);
        return SOFTBUS_ERR;
    }

    // âœ… æ£€æŸ¥è¿”å›å€¼
    err = strcpy_s(dst, dstSize, src);
    if (err != 0) {
        HILOG_ERROR("strcpy_s failed: %{public}d", err);
        return SOFTBUS_ERR;
    }

    return SOFTBUS_OK;
}
```

**æ£€æŸ¥è¦ç‚¹**ï¼š
- æ‰€æœ‰ *_s å‡½æ•°å¿…é¡»æ£€æŸ¥è¿”å›å€¼
- memcpy_s, memmove_s, memset_s
- strcpy_s, strncpy_s, strcat_s
- sprintf_s, snprintf_s
- è¿”å›å€¼ç±»å‹é€šå¸¸æ˜¯ errno_t

---

### è§„åˆ™ 11.2: ç›®æ ‡ç¼“å†²åŒºå¤§å°å…¥å‚ä¸å®é™…å¤§å°ä¸€è‡´æ€§

**é—®é¢˜æè¿°**ï¼š
ç¼“å†²åŒºå¤§å°å‚æ•°ä¸å®é™…å¤§å°ä¸ä¸€è‡´ã€‚

**é£é™©ç­‰çº§**ï¼šğŸ”´ ä¸¥é‡

**é—®é¢˜ç¤ºä¾‹**ï¼š
```c
#define BUFFER_SIZE 256
char g_buffer[BUFFER_SIZE];

int32_t StoreData(const char *data) {
    // âŒ ç¼“å†²åŒºå¤§å°ä¸ä¸€è‡´
    strcpy_s(g_buffer, 1024, data);  // å®é™…åªæœ‰256å­—èŠ‚
    return SOFTBUS_OK;
}
```

**ä¿®å¤æ–¹æ¡ˆ**ï¼š
```c
#define BUFFER_SIZE 256
char g_buffer[BUFFER_SIZE];

int32_t StoreData(const char *data) {
    // âœ… ä½¿ç”¨æ­£ç¡®çš„ç¼“å†²åŒºå¤§å°
    errno_t err = strcpy_s(g_buffer, BUFFER_SIZE, data);
    if (err != 0) {
        HILOG_ERROR("strcpy_s failed: %{public}d", err);
        return SOFTBUS_ERR;
    }
    return SOFTBUS_OK;
}

// æˆ–è€…ä½¿ç”¨ sizeof
int32_t StoreData(const char *data) {
    errno_t err = strcpy_s(g_buffer, sizeof(g_buffer), data);
    if (err != 0) {
        HILOG_ERROR("strcpy_s failed: %{public}d", err);
        return SOFTBUS_ERR;
    }
    return SOFTBUS_OK;
}
```

**æ£€æŸ¥è¦ç‚¹**ï¼š
- ç¼“å†²åŒºå¤§å°å‚æ•°åº”ä¸å®é™…å¤§å°ä¸€è‡´
- ä¼˜å…ˆä½¿ç”¨ `sizeof(buffer)` è€Œéç¡¬ç¼–ç å€¼
- åŠ¨æ€åˆ†é…çš„å†…å­˜ä½¿ç”¨å®é™…åˆ†é…å¤§å°

---

## 12. æƒé™æ ¡éªŒæ£€æŸ¥

### è§„åˆ™ 12.1: æ–°å¢ SDK IPC æ¥å£æƒé™æ ¡éªŒ

**é—®é¢˜æè¿°**ï¼š
æ–°å¢ SDK IPC æ¥å£æœªè¿›è¡Œæƒé™æ ¡éªŒï¼Œå¯èƒ½å¯¼è‡´æœªæˆæƒè®¿é—®ã€‚

**é£é™©ç­‰çº§**ï¼šğŸ”´ ä¸¥é‡

**é—®é¢˜ç¤ºä¾‹**ï¼š
```c
int32_t DeleteDevice(const char *networkId) {
    // âŒ æœªæ ¡éªŒè°ƒç”¨è€…æƒé™
    if (networkId == NULL) {
        return SOFTBUS_INVALID_PARAM;
    }

    // ç›´æ¥æ‰§è¡Œåˆ é™¤æ“ä½œ
    return RemoveDevice(networkId);
}
```

**ä¿®å¤æ–¹æ¡ˆ**ï¼š
```c
int32_t DeleteDevice(const char *networkId) {
    // âœ… æ ¡éªŒè°ƒç”¨è€…èº«ä»½
    if (!CheckCallerPermission(PERMISSION_DEVICE_MANAGE)) {
        HILOG_ERROR("Permission denied: no DEVICE_MANAGE permission");
        return SOFTBUS_PERMISSION_DENIED;
    }

    if (networkId == NULL) {
        return SOFTBUS_INVALID_PARAM;
    }

    // æ‰§è¡Œåˆ é™¤æ“ä½œ
    return RemoveDevice(networkId);
}
```

**æ£€æŸ¥è¦ç‚¹**ï¼š
- æ‰€æœ‰ IPC æ¥å£å¿…é¡»æ ¡éªŒæƒé™
- æ£€æŸ¥è°ƒç”¨è€…èº«ä»½å’Œæƒé™
- è®°å½•æƒé™æ‹’ç»æ—¥å¿—
- æ–°å¢æ¥å£å¿…é¡»è¿›è¡Œå®‰å…¨è¯„å®¡

---

## 13-15. å…¶ä»–è§„åˆ™ï¼ˆç®€è¦è¯´æ˜ï¼‰

ç”±äºç¯‡å¹…é™åˆ¶ï¼Œå‰©ä½™è§„åˆ™åœ¨æ­¤ç®€è¦è¯´æ˜ã€‚å®Œæ•´ç¤ºä¾‹è¯·å‚è€ƒ SKILL.md æ–‡æ¡£ä¸­çš„"å¸¸è§è¿è§„æ¨¡å¼"éƒ¨åˆ†ã€‚

### 13. å¤–éƒ¨è¾“å…¥æ ¡éªŒæ£€æŸ¥

- **è·¯å¾„è§„èŒƒåŒ–**ï¼šæ£€æŸ¥ `..`, `.`, `../` ç­‰è·¯å¾„éå†å­—ç¬¦
- **TLV è§£æé•¿åº¦åˆæ³•æ€§**ï¼šlength <= buffer å®é™…å¤§å°
- **æº buffer å®é™…å¤§å°**ï¼šæ‹·è´æ—¶éªŒè¯æºç¼“å†²åŒºå¤§å°
- **å®Œæ•´æ ¡éªŒæ–¹æ¡ˆ**ï¼šç»¼åˆæ ¡éªŒæ‰€æœ‰å¤–éƒ¨è¾“å…¥

### 14. å¤–éƒ¨æ•°æ®æœ‰æ•ˆæ€§æ£€æŸ¥

- **åŸºäºå¤–éƒ¨è¾“å…¥çš„è¿ç®—**ï¼šåŠ å‡æ³•ã€å†…å­˜ç”³è¯·å‰æ ¡éªŒ
- **é»˜è®¤é•¿åº¦æ ¡éªŒ**ï¼šä¸ä½¿ç”¨é»˜è®¤é•¿åº¦ï¼Œè§£æå®é™…é•¿åº¦
- **TLV æ ¼å¼é•¿åº¦æ ¡éªŒ**ï¼šéªŒè¯ length å­—æ®µåˆæ³•æ€§

### 15. å¸¸è§é—®é¢˜æ£€æŸ¥

- **å¼‚å¸¸åˆ†æ”¯èµ„æºé‡Šæ”¾**ï¼šæ‰€æœ‰é”™è¯¯è·¯å¾„é‡Šæ”¾èµ„æº
- **å®å®šä¹‰èµ„æºæ³„æ¼**ï¼šCHECK_AND_RETURN_LOG_INNER ç­‰å®
- **å‡½æ•°è¿”å›å€¼ä¸€è‡´æ€§**ï¼šè¿”å›å€¼ç±»å‹ä¸å‡½æ•°ç­¾åä¸€è‡´
- **æ ¼å¼åŒ–æ‰“å°ç±»å‹åŒ¹é…**ï¼šä½¿ç”¨æ­£ç¡®çš„æ ¼å¼è¯´æ˜ç¬¦
- **ç»“æ„ä½“å­—èŠ‚å¯¹é½**ï¼šæ³¨æ„ packed ç»“æ„ä½“

---

## æ£€æŸ¥æ¸…å•

> ğŸ“‹ **å¿«é€Ÿå‚è€ƒ**: å¦‚éœ€å¿«é€ŸæŸ¥é˜…è§„åˆ™ç´¢å¼•å’Œå¸¸è§é”™è¯¯é€ŸæŸ¥è¡¨ï¼Œè¯·æŸ¥çœ‹ [ä¸»æ–‡æ¡£ - å¸¸è§é”™è¯¯é€ŸæŸ¥è¡¨](../skill.md#å¸¸è§é”™è¯¯é€ŸæŸ¥è¡¨)

### å¿«é€Ÿæ£€æŸ¥æ¸…å•

ä½¿ç”¨ä»¥ä¸‹æ¸…å•å¿«é€ŸéªŒè¯ä»£ç ï¼š

- [ ] æ‰€æœ‰è¿”å› SOFTBUS_ERR çš„åœ°æ–¹æ˜¯å¦å¯ä»¥ç”¨å…·ä½“é”™è¯¯ç 
- [ ] æ‰€æœ‰ `*ptr` å’Œ `ptr->` ä½¿ç”¨å‰æ˜¯å¦åˆ¤ç©º
- [ ] æ‰€æœ‰æ•°ç»„è®¿é—®æ˜¯å¦éªŒè¯ä¸‹æ ‡èŒƒå›´
- [ ] æ‰€æœ‰ Lock æ˜¯å¦æœ‰å¯¹åº”çš„ Unlock
- [ ] æ‰€æœ‰ malloc æ˜¯å¦æœ‰å¯¹åº”çš„ free
- [ ] æ‰€æœ‰æ•æ„Ÿä¿¡æ¯æ˜¯å¦ä½¿ç”¨ `%{private}` æˆ–ä¸æ‰“å°
- [ ] æ‰€æœ‰å¾ªç¯å˜é‡ç±»å‹æ˜¯å¦æ­£ç¡®ï¼ˆé¿å…æ— ç¬¦å·é€’å‡ï¼‰
- [ ] æ‰€æœ‰å¤–éƒ¨è¾“å…¥æ˜¯å¦æ ¡éªŒåˆæ³•æ€§
- [ ] æ‰€æœ‰å®‰å…¨å‡½æ•°è¿”å›å€¼æ˜¯å¦æ£€æŸ¥
- [ ] æ‰€æœ‰ fd/socket æ˜¯å¦æ­£ç¡®å…³é—­

### é«˜é£é™©ä»£ç æ¨¡å¼

ä»¥ä¸‹æ¨¡å¼éœ€è¦ç‰¹åˆ«å…³æ³¨ï¼š

```c
// é«˜é£é™©ï¼šæœªç»æ ¡éªŒçš„å¤–éƒ¨è¾“å…¥
arr[external_index]
char *ptr = ExternalFunc();  // ç›´æ¥ä½¿ç”¨

// é«˜é£é™©ï¼šèµ„æºç®¡ç†
malloc  without  free
lock    without  unlock
open    without  close

// é«˜é£é™©ï¼šæ•´æ•°è¿ç®—
a + b  // å¯èƒ½æº¢å‡º
a * b  // å¯èƒ½æº¢å‡º
a / b  // å¯èƒ½é™¤é›¶

// é«˜é£é™©ï¼šç±»å‹è½¬æ¢
(uint32_t)signed_var  // å¯èƒ½æˆªæ–­
(char *)raw_addr      // å¯èƒ½æœªå¯¹é½
```

---

## æ€»ç»“

æœ¬æ–‡æ¡£è¯¦ç»†è¯´æ˜äº†è½¯æ€»çº¿å®‰å…¨å«å£«çš„40+æ¡å®‰å…¨è§„åˆ™ã€‚åœ¨ä»£ç å®¡æŸ¥æ—¶ï¼š

1. **ä½¿ç”¨å¿«é€Ÿå‚è€ƒè¡¨æ ¼**å¿«é€Ÿå®šä½ç›¸å…³è§„åˆ™ï¼ˆ[ä¸»æ–‡æ¡£](../skill.md)ï¼‰
2. **æ£€æŸ¥å¸¸è§è¿è§„æ¨¡å¼**é¿å…é‡å¤é”™è¯¯
3. **å‚è€ƒæœ¬æ–‡æ¡£çš„è¯¦ç»†ç¤ºä¾‹**ç†è§£æ¯æ¡è§„åˆ™
4. **ä½¿ç”¨æ£€æŸ¥æ¸…å•**é€é¡¹éªŒè¯ä»£ç 

è®°ä½ï¼š**ä¸Šä¸‹æ–‡åˆ†æå¾ˆé‡è¦**ã€‚åœ¨æŠ¥å‘Šé—®é¢˜æ—¶ï¼Œè¦è€ƒè™‘ä»£ç çš„ä¸Šä¸‹æ–‡ï¼Œé¿å…è¯¯æŠ¥ã€‚æŸäº›æƒ…å†µå¯èƒ½æœ‰åˆç†çš„ç†ç”±è¿åè§„åˆ™ï¼ˆå¦‚ï¼šå…¨å±€å˜é‡åœ¨åˆ«å¤„åˆå§‹åŒ–ï¼‰ã€‚

---

## ğŸ“‹ é™„å½•ï¼šå‚è€ƒè¡¨æ ¼

### æ ¼å¼åŒ–æ‰“å°ç±»å‹åŒ¹é…è¡¨

| ç±»å‹ | æ­£ç¡®æ ¼å¼è¯´æ˜ç¬¦ | å¸¸è§é”™è¯¯ | è¯´æ˜ |
|------|---------------|---------|------|
| int32_t | `%d` | ä½¿ç”¨`%u` | æœ‰ç¬¦å·32ä½æ•´æ•° |
| uint32_t | `%u` | ä½¿ç”¨`%d` | æ— ç¬¦å·32ä½æ•´æ•° |
| int64_t | `%lld` æˆ– `PRId64` | ä½¿ç”¨`%d` | æœ‰ç¬¦å·64ä½æ•´æ•° |
| uint64_t | `%llu` æˆ– `PRIu64` | ä½¿ç”¨`%u` | æ— ç¬¦å·64ä½æ•´æ•° |
| int8_t | `%hhd` | ä½¿ç”¨`%d` | æœ‰ç¬¦å·8ä½æ•´æ•° |
| uint8_t | `%hhu` | ä½¿ç”¨`%d` | æ— ç¬¦å·8ä½æ•´æ•° |
| æŒ‡é’ˆ | `%p` | ä½¿ç”¨`0x%x` | å†…å­˜åœ°å€ |

**ä½¿ç”¨å»ºè®®**ï¼š
- ä¼˜å…ˆä½¿ç”¨ `<inttypes.h>` ä¸­çš„å®ï¼ˆ`PRId64`, `PRIu64` ç­‰ï¼‰ä»¥ä¿è¯å¯ç§»æ¤æ€§
- æŒ‡é’ˆæ‰“å°ä½¿ç”¨ `%p`ï¼Œä¸è¦å¼ºåˆ¶è½¬æ¢ä¸ºæ•´æ•°åæ‰“å°
- æ•æ„Ÿä¿¡æ¯ä½¿ç”¨ `%{private}s` åŒ¿ååŒ–

### å¸¸ç”¨å®‰å…¨å‡½æ•°åˆ—è¡¨

| å‡½æ•° | è¿”å›å€¼æ£€æŸ¥ | å‚æ•°è¦æ±‚ | è¯´æ˜ |
|------|-----------|---------|------|
| `memcpy_s` | âœ… å¿…é¡»æ£€æŸ¥ | ç›®æ ‡ç¼“å†²åŒºå¤§å°å¿…é¡»æ­£ç¡® | å®‰å…¨å†…å­˜æ‹·è´ |
| `memmove_s` | âœ… å¿…é¡»æ£€æŸ¥ | ç›®æ ‡ç¼“å†²åŒºå¤§å°å¿…é¡»æ­£ç¡® | å®‰å…¨å†…å­˜ç§»åŠ¨ï¼ˆå¤„ç†é‡å ï¼‰ |
| `memset_s` | âœ… å»ºè®®æ£€æŸ¥ | ç›®æ ‡ç¼“å†²åŒºå¤§å°å¿…é¡»æ­£ç¡® | å®‰å…¨å†…å­˜å¡«å…… |
| `strcpy_s` | âœ… å¿…é¡»æ£€æŸ¥ | ç›®æ ‡ç¼“å†²åŒºå¤§å°å¿…é¡»æ­£ç¡® | å®‰å…¨å­—ç¬¦ä¸²æ‹·è´ |
| `strncpy_s` | âœ… å¿…é¡»æ£€æŸ¥ | ç›®æ ‡ç¼“å†²åŒºå¤§å°å¿…é¡»æ­£ç¡® | å®‰å…¨å­—ç¬¦ä¸²é™åˆ¶æ‹·è´ |
| `strcat_s` | âœ… å¿…é¡»æ£€æŸ¥ | ç›®æ ‡ç¼“å†²åŒºå¤§å°å¿…é¡»æ­£ç¡® | å®‰å…¨å­—ç¬¦ä¸²è¿æ¥ |
| `sprintf_s` | âœ… å¿…é¡»æ£€æŸ¥ | ç›®æ ‡ç¼“å†²åŒºå¤§å°å¿…é¡»æ­£ç¡® | å®‰å…¨æ ¼å¼åŒ–è¾“å‡º |
| `snprintf_s` | âœ… å¿…é¡»æ£€æŸ¥ | ç›®æ ‡ç¼“å†²åŒºå¤§å°å¿…é¡»æ­£ç¡® | å®‰å…¨é™åˆ¶æ ¼å¼åŒ–è¾“å‡º |
| `SoftBusMalloc` | âœ… å¿…é¡»åˆ¤ç©º | - | å†…å­˜åˆ†é… |
| `SoftBusCalloc` | âœ… å¿…é¡»åˆ¤ç©º | - | å†…å­˜åˆ†é…ï¼ˆæ¸…é›¶ï¼‰ |
| `SoftBusMutexLock` | âœ… å¿…é¡»æ£€æŸ¥è¿”å›å€¼ | - | åŠ é” |
| `SoftBusMutexInit` | âœ… å¿…é¡»æ£€æŸ¥è¿”å›å€¼ | - | é”åˆå§‹åŒ– |

**ä½¿ç”¨å»ºè®®**ï¼š
- æ‰€æœ‰ `_s` åç¼€çš„å®‰å…¨å‡½æ•°è¿”å›å€¼ç±»å‹ä¸º `errno_t`ï¼ŒæˆåŠŸæ—¶è¿”å› `0`ï¼ˆ`EOK`ï¼‰
- `memcpy_s` ç­‰å‡½æ•°åœ¨è¿è¡Œæ—¶æ£€æŸ¥ç¼“å†²åŒºè¾¹ç•Œï¼Œé˜²æ­¢æº¢å‡º
- `SoftBusMalloc` å¤±è´¥è¿”å› `NULL`ï¼Œå¿…é¡»åœ¨ä½¿ç”¨å‰æ£€æŸ¥
- `SoftBusMutexLock` å¤±è´¥å¯èƒ½å¯¼è‡´æ­»é”ï¼Œå¿…é¡»æ£€æŸ¥è¿”å›å€¼

### å¸¸ç”¨é”™è¯¯ç é€ŸæŸ¥

| é”™è¯¯ç  | å«ä¹‰ | ä½¿ç”¨åœºæ™¯ |
|--------|------|---------|
| `SOFTBUS_OK` | æˆåŠŸ | æ“ä½œæˆåŠŸè¿”å› |
| `SOFTBUS_ERR` | âŒ é€šç”¨é”™è¯¯ | **ç¦æ­¢ä½¿ç”¨**ï¼Œåº”ä½¿ç”¨å…·ä½“é”™è¯¯ç  |
| `SOFTBUS_INVALID_PARAM` | å‚æ•°æ— æ•ˆ | å‚æ•°ä¸ºNULLã€è¶Šç•Œç­‰ |
| `SOFTBUS_MALLOC_ERR` | å†…å­˜åˆ†é…å¤±è´¥ | malloc/calloc è¿”å›NULL |
| `SOFTBUS_MEM_ERR` | å†…å­˜æ“ä½œå¤±è´¥ | memcpy_sç­‰å¤±è´¥ |
| `SOFTBUS_LOCK_ERR` | é”æ“ä½œå¤±è´¥ | MutexLock/Initå¤±è´¥ |
| `SOFTBUS_MUTEX_ERR` | äº’æ–¥é”é”™è¯¯ | é”ç›¸å…³é”™è¯¯ |
| `SOFTBUS_SOCKET_ERR` | Socketé”™è¯¯ | socketæ“ä½œå¤±è´¥ |
| `SOFTBUS_READ_MSG_ERR` | è¯»å–æ¶ˆæ¯å¤±è´¥ | IPCè¯»å–å¤±è´¥ |
| `SOFTBUS_PERMISSION_DENIED` | æƒé™æ‹’ç» | æƒé™æ ¡éªŒå¤±è´¥ |
| `SOFTBUS_NO_INIT` | æœªåˆå§‹åŒ– | æ¨¡å—æœªåˆå§‹åŒ– |
| `SOFTBUS_LANE_NOT_FOUND` | Laneæœªæ‰¾åˆ° | ç‰¹å®šåœºæ™¯é”™è¯¯ç  |

**ä½¿ç”¨åŸåˆ™**ï¼š
- âœ… è¿”å›å…·ä½“çš„é”™è¯¯ç ï¼Œä¾¿äºé—®é¢˜å®šä½
- âŒ ç¦æ­¢ä½¿ç”¨ `SOFTBUS_ERR` é€šç”¨é”™è¯¯ç 
- ğŸ“ é”™è¯¯æ—¥å¿—åº”åŒ…å«å…·ä½“çš„é”™è¯¯ä¿¡æ¯

---

**ğŸ“– è¿”å›ä¸»æ–‡æ¡£**: [è½¯æ€»çº¿å®‰å…¨å«å£«æŠ€èƒ½è¯´æ˜](../skill.md)

